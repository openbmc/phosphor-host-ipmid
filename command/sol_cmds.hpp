#pragma once

#include "message_handler.hpp"

#include <vector>

namespace sol
{

namespace command
{

/** @brief SOL Payload Handler
 *
 *  This command is used for activating and deactivating a payload type under a
 *  given IPMI session. The UDP Port number for SOL is the same as the port that
 *  was used to establish the IPMI session.
 *
 *  @param[in] inPayload - Request data for the command.
 *  @param[in] handler - Reference to the message handler.
 *
 *  @return Response data for the command.
 */
std::vector<uint8_t> payloadHandler(const std::vector<uint8_t>& inPayload,
                                    std::shared_ptr<message::Handler>& handler);

constexpr uint8_t netfnTransport = 0x0C;
constexpr uint8_t solActivatingCmd = 0x20;

/** @struct ActivatingRequest
 *
 *  IPMI payload for SOL Activating command.
 */
struct ActivatingRequest
{
#if BYTE_ORDER == LITTLE_ENDIAN
    uint8_t sessionState : 4; //!< SOL session state.
    uint8_t reserved : 4;     //!< Reserved.
#endif

#if BYTE_ORDER == BIG_ENDIAN
    uint8_t reserved : 4;     //!< Reserved.
    uint8_t sessionState : 4; //!< SOL session state.
#endif

    uint8_t payloadInstance; //!< Payload instance.
    uint8_t majorVersion;    //!< SOL format major version
    uint8_t minorVersion;    //!< SOL format minor version
} __attribute__((packed));

/** @brief SOL Activating Command.
 *
 *  This command provides a mechanism for the BMC to notify a remote application
 *  that a SOL payload is activating on another channel.The request message is a
 *  message that is asynchronously generated by the BMC. The BMC will not wait
 *  for a response from the remote console before dropping the serial connection
 *  to proceed with SOL, therefore the remote console does not need to respond
 *  to this command.
 *
 *  @param[in] payloadInstance - SOL payload instance.
 *  @param[in] sessionID - IPMI session ID.
 */
void activating(uint8_t payloadInstance, uint32_t sessionID);

} // namespace command

} // namespace sol
