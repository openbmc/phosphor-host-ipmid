{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "7967f4a8_ce714dfe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 1000265
      },
      "writtenOn": "2024-08-09T01:08:07Z",
      "side": 1,
      "message": "PTAL",
      "revId": "8ebb64d583ecad6df9ec63a1412539c4bcedded6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "01bf01c8_39ee8261",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 1000163
      },
      "writtenOn": "2024-08-13T17:46:52Z",
      "side": 1,
      "message": "I am a a bit anti-cache unless there is a good performance (or other) improvement. They increase complexity and contribute to bugs like this. I would prefer that ipmid did not cache the fru at all, and only have the cache (and write timeout) at the level that is actually doing the writing.\n\nIf we have to send the fru data over D-BUS and then have no guarantees that when we read back the value that it is not coherent, our caches are very broken. I don\u0027t like the idea of adding (or changing) the ipmid fru cache to paper over what seems to be a bug in the ipmi-fru-parser code. We should just fix the improper caching there.\n\nI think the correct behavior is that ipmid merely extracts the fru data and address/offset from the ipmi command and passes it on to the ipmi-fru-parser. That code should keep a coherent cache (so that even if it hasn\u0027t written through to the backing storage, it will still present the freshest data). It should keep the timer to minimize read/copy/erase/write cycles in the storage by grouping writes together. It can also be the arbiter of what writes are in and out of bounds and respond with an error when ipmid tries to write beyond the end of storage.",
      "revId": "8ebb64d583ecad6df9ec63a1412539c4bcedded6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "073f79e9_3ba0bed4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 1000265
      },
      "writtenOn": "2024-08-13T18:39:45Z",
      "side": 1,
      "message": "The problem is that the IPMI FRU writes come in several IPMI calls. We need to give the caller the opportunity to complete all these calls before sending it on to the storage backend. The storage backend will not accept a FRU that is not \"complete\" i.e. that does not parse. It would also allow a caller to perform a \"partial\" write and potentially corrupt the contents of the FRU. So with that, the write cache is essential to the correct functioning of the system.\n\nThe read cache is important to provide acceptable performance to the IPMI caller for reading the FRU or for figuring out details of the FRU (ipmiStorageGetFruInvAreaInfo). Dropping the read cache would have a notable performance degradation for callers.\n\nAlso note that the storage backend notifies us via D-bus if the contents of the FRU change, which allows the cached to be flushed.\n\nI share your sentiment of not having caches. I\u0027m afraid that with the current architecture of phosphor-host-ipmid and the underlying entity-manager (which acts as a storage backend) alongside IPMI\u0027s protocol I cannot see how caches could be dropped. If the storage backend and the host-ipmid were integrated into one process, we could consider dropping the read cache. I still don\u0027t see how the write cache could be dropped.\n\nNote that this code is a straightforward improvement over the previous implementation where the read and write cache was shared, causing random behavior to clients.",
      "parentUuid": "01bf01c8_39ee8261",
      "revId": "8ebb64d583ecad6df9ec63a1412539c4bcedded6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c57fa94_08d1999c",
        "filename": "dbus-sdr/storagecommands.cpp",
        "patchSetId": 11
      },
      "lineNbr": 126,
      "author": {
        "id": 1000163
      },
      "writtenOn": "2024-11-05T00:07:23Z",
      "side": 1,
      "message": "adding const to functions that don\u0027t change the object makes it easier to use const objects and const refs.",
      "revId": "8ebb64d583ecad6df9ec63a1412539c4bcedded6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a9cbd17b_fce71c14",
        "filename": "dbus-sdr/storagecommands.cpp",
        "patchSetId": 11
      },
      "lineNbr": 136,
      "author": {
        "id": 1000163
      },
      "writtenOn": "2024-11-05T00:07:23Z",
      "side": 1,
      "message": "It might be more appropriate to have an append_data function and make this return a const\u0026.",
      "revId": "8ebb64d583ecad6df9ec63a1412539c4bcedded6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd634de3_b5eedafc",
        "filename": "dbus-sdr/storagecommands.cpp",
        "patchSetId": 11
      },
      "lineNbr": 155,
      "author": {
        "id": 1000163
      },
      "writtenOn": "2024-11-05T00:07:23Z",
      "side": 1,
      "message": "Please don\u0027t use m as a prefix for member variables. Just give them names.",
      "range": {
        "startLine": 152,
        "startChar": 0,
        "endLine": 155,
        "endChar": 18
      },
      "revId": "8ebb64d583ecad6df9ec63a1412539c4bcedded6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b94c83d_dd6b00d7",
        "filename": "dbus-sdr/storagecommands.cpp",
        "patchSetId": 11
      },
      "lineNbr": 178,
      "author": {
        "id": 1000163
      },
      "writtenOn": "2024-11-05T00:07:23Z",
      "side": 1,
      "message": "const FruCache\u0026",
      "revId": "8ebb64d583ecad6df9ec63a1412539c4bcedded6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "228ab45e_3c5b60bb",
        "filename": "dbus-sdr/storagecommands.cpp",
        "patchSetId": 11
      },
      "lineNbr": 210,
      "author": {
        "id": 1000163
      },
      "writtenOn": "2024-11-05T00:07:23Z",
      "side": 1,
      "message": "Is there a retry mechanism for if the write failed?",
      "revId": "8ebb64d583ecad6df9ec63a1412539c4bcedded6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc0b92f7_4d4b4d4a",
        "filename": "dbus-sdr/storagecommands.cpp",
        "patchSetId": 11
      },
      "lineNbr": 497,
      "author": {
        "id": 1000163
      },
      "writtenOn": "2024-11-05T00:07:23Z",
      "side": 1,
      "message": "I think there\u0027s a race condition here between the write timer and modifying the fruCacheForWriting. Before calling getFru, you need to stop the write timer.",
      "revId": "8ebb64d583ecad6df9ec63a1412539c4bcedded6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}