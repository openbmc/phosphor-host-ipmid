// This file was autogenerated.  Do not edit!
// See elog-gen.py for more details
#pragma once

#include <phosphor-logging/elog.hpp>
#include <phosphor-logging/log.hpp>
#include <sdbusplus/exception.hpp>
#include <string>
#include <tuple>
#include <type_traits>

namespace sdbusplus::error::com::google::gbmc::hoth
{
struct CommandFailure;
} // namespace sdbusplus::error::com::google::gbmc::hoth
namespace sdbusplus::error::com::google::gbmc::hoth
{
struct ExpectedInfoNotFound;
} // namespace sdbusplus::error::com::google::gbmc::hoth
namespace sdbusplus::error::com::google::gbmc::hoth
{
struct FirmwareFailure;
} // namespace sdbusplus::error::com::google::gbmc::hoth
namespace sdbusplus::error::com::google::gbmc::hoth
{
struct InterfaceError;
} // namespace sdbusplus::error::com::google::gbmc::hoth
namespace sdbusplus::error::com::google::gbmc::hoth
{
struct ResponseFailure;
} // namespace sdbusplus::error::com::google::gbmc::hoth
namespace sdbusplus::error::com::google::gbmc::hoth
{
struct ResponseNotFound;
} // namespace sdbusplus::error::com::google::gbmc::hoth
namespace sdbusplus::error::com::ibm::vpd
{
struct BlankSystemVPD;
} // namespace sdbusplus::error::com::ibm::vpd
namespace sdbusplus::error::com::ibm::vpd
{
struct DbusFailure;
} // namespace sdbusplus::error::com::ibm::vpd
namespace sdbusplus::error::com::ibm::vpd
{
struct EccCheckFailed;
} // namespace sdbusplus::error::com::ibm::vpd
namespace sdbusplus::error::com::ibm::vpd
{
struct InvalidEepromPath;
} // namespace sdbusplus::error::com::ibm::vpd
namespace sdbusplus::error::com::ibm::vpd
{
struct InvalidJson;
} // namespace sdbusplus::error::com::ibm::vpd
namespace sdbusplus::error::com::ibm::vpd
{
struct InvalidVPD;
} // namespace sdbusplus::error::com::ibm::vpd
namespace sdbusplus::error::com::ibm::vpd
{
struct KeywordNotFound;
} // namespace sdbusplus::error::com::ibm::vpd
namespace sdbusplus::error::com::ibm::vpd
{
struct LocationNotFound;
} // namespace sdbusplus::error::com::ibm::vpd
namespace sdbusplus::error::com::ibm::vpd
{
struct NodeNotFound;
} // namespace sdbusplus::error::com::ibm::vpd
namespace sdbusplus::error::com::ibm::vpd
{
struct PathNotFound;
} // namespace sdbusplus::error::com::ibm::vpd
namespace sdbusplus::error::com::ibm::vpd
{
struct RecordNotFound;
} // namespace sdbusplus::error::com::ibm::vpd
namespace sdbusplus::error::org::open_power::common::callout
{
struct Procedure;
} // namespace sdbusplus::error::org::open_power::common::callout
namespace sdbusplus::error::org::open_power::host::access
{
struct ReadCFAM;
} // namespace sdbusplus::error::org::open_power::host::access
namespace sdbusplus::error::org::open_power::host::access
{
struct WriteCFAM;
} // namespace sdbusplus::error::org::open_power::host::access
namespace sdbusplus::error::org::open_power::host::boot
{
struct Checkstop;
} // namespace sdbusplus::error::org::open_power::host::boot
namespace sdbusplus::error::org::open_power::host::boot
{
struct WatchdogTimedOut;
} // namespace sdbusplus::error::org::open_power::host::boot
namespace sdbusplus::error::org::open_power::host
{
struct Event;
} // namespace sdbusplus::error::org::open_power::host
namespace sdbusplus::error::org::open_power::host
{
struct MaintenanceProcedure;
} // namespace sdbusplus::error::org::open_power::host
namespace sdbusplus::error::org::open_power::occ::device
{
struct ConfigFailure;
} // namespace sdbusplus::error::org::open_power::occ::device
namespace sdbusplus::error::org::open_power::occ::device
{
struct OpenFailure;
} // namespace sdbusplus::error::org::open_power::occ::device
namespace sdbusplus::error::org::open_power::occ::device
{
struct ReadFailure;
} // namespace sdbusplus::error::org::open_power::occ::device
namespace sdbusplus::error::org::open_power::occ::device
{
struct WriteFailure;
} // namespace sdbusplus::error::org::open_power::occ::device
namespace sdbusplus::error::org::open_power::proc::fsi
{
struct MasterDetectionFailure;
} // namespace sdbusplus::error::org::open_power::proc::fsi
namespace sdbusplus::error::org::open_power::proc::fsi
{
struct SlaveDetectionFailure;
} // namespace sdbusplus::error::org::open_power::proc::fsi
namespace sdbusplus::error::xyz::openbmc_project::bios_config::common
{
struct AttributeNotFound;
} // namespace sdbusplus::error::xyz::openbmc_project::bios_config::common
namespace sdbusplus::error::xyz::openbmc_project::bios_config::common
{
struct AttributeReadOnly;
} // namespace sdbusplus::error::xyz::openbmc_project::bios_config::common
namespace sdbusplus::error::xyz::openbmc_project::bios_config::common
{
struct InvalidCurrentPassword;
} // namespace sdbusplus::error::xyz::openbmc_project::bios_config::common
namespace sdbusplus::error::xyz::openbmc_project::bios_config::common
{
struct PasswordNotSettable;
} // namespace sdbusplus::error::xyz::openbmc_project::bios_config::common
namespace sdbusplus::error::xyz::openbmc_project::certs
{
struct InvalidCertificate;
} // namespace sdbusplus::error::xyz::openbmc_project::certs
namespace sdbusplus::error::xyz::openbmc_project::chassis::common
{
struct IOError;
} // namespace sdbusplus::error::xyz::openbmc_project::chassis::common
namespace sdbusplus::error::xyz::openbmc_project::chassis::common
{
struct UnsupportedCommand;
} // namespace sdbusplus::error::xyz::openbmc_project::chassis::common
namespace sdbusplus::error::xyz::openbmc_project::common::callout
{
struct Device;
} // namespace sdbusplus::error::xyz::openbmc_project::common::callout
namespace sdbusplus::error::xyz::openbmc_project::common::callout
{
struct GPIO;
} // namespace sdbusplus::error::xyz::openbmc_project::common::callout
namespace sdbusplus::error::xyz::openbmc_project::common::callout
{
struct IIC;
} // namespace sdbusplus::error::xyz::openbmc_project::common::callout
namespace sdbusplus::error::xyz::openbmc_project::common::callout
{
struct IPMISensor;
} // namespace sdbusplus::error::xyz::openbmc_project::common::callout
namespace sdbusplus::error::xyz::openbmc_project::common::callout
{
struct Inventory;
} // namespace sdbusplus::error::xyz::openbmc_project::common::callout
namespace sdbusplus::error::xyz::openbmc_project::common::device
{
struct ReadFailure;
} // namespace sdbusplus::error::xyz::openbmc_project::common::device
namespace sdbusplus::error::xyz::openbmc_project::common::device
{
struct WriteFailure;
} // namespace sdbusplus::error::xyz::openbmc_project::common::device
namespace sdbusplus::error::xyz::openbmc_project::common::file
{
struct Open;
} // namespace sdbusplus::error::xyz::openbmc_project::common::file
namespace sdbusplus::error::xyz::openbmc_project::common::file
{
struct Read;
} // namespace sdbusplus::error::xyz::openbmc_project::common::file
namespace sdbusplus::error::xyz::openbmc_project::common::file
{
struct Seek;
} // namespace sdbusplus::error::xyz::openbmc_project::common::file
namespace sdbusplus::error::xyz::openbmc_project::common::file
{
struct Write;
} // namespace sdbusplus::error::xyz::openbmc_project::common::file
namespace sdbusplus::error::xyz::openbmc_project::common
{
struct InsufficientPermission;
} // namespace sdbusplus::error::xyz::openbmc_project::common
namespace sdbusplus::error::xyz::openbmc_project::common
{
struct InternalFailure;
} // namespace sdbusplus::error::xyz::openbmc_project::common
namespace sdbusplus::error::xyz::openbmc_project::common
{
struct InvalidArgument;
} // namespace sdbusplus::error::xyz::openbmc_project::common
namespace sdbusplus::error::xyz::openbmc_project::common
{
struct NoCACertificate;
} // namespace sdbusplus::error::xyz::openbmc_project::common
namespace sdbusplus::error::xyz::openbmc_project::common
{
struct NotAllowed;
} // namespace sdbusplus::error::xyz::openbmc_project::common
namespace sdbusplus::error::xyz::openbmc_project::common
{
struct ResourceNotFound;
} // namespace sdbusplus::error::xyz::openbmc_project::common
namespace sdbusplus::error::xyz::openbmc_project::common
{
struct Timeout;
} // namespace sdbusplus::error::xyz::openbmc_project::common
namespace sdbusplus::error::xyz::openbmc_project::common
{
struct TooManyResources;
} // namespace sdbusplus::error::xyz::openbmc_project::common
namespace sdbusplus::error::xyz::openbmc_project::common
{
struct Unavailable;
} // namespace sdbusplus::error::xyz::openbmc_project::common
namespace sdbusplus::error::xyz::openbmc_project::common
{
struct UnsupportedRequest;
} // namespace sdbusplus::error::xyz::openbmc_project::common
namespace sdbusplus::error::xyz::openbmc_project::control::device
{
struct WriteFailure;
} // namespace sdbusplus::error::xyz::openbmc_project::control::device
namespace sdbusplus::error::xyz::openbmc_project::control::host
{
struct CommandNotSupported;
} // namespace sdbusplus::error::xyz::openbmc_project::control::host
namespace sdbusplus::error::xyz::openbmc_project::dump::create
{
struct Disabled;
} // namespace sdbusplus::error::xyz::openbmc_project::dump::create
namespace sdbusplus::error::xyz::openbmc_project::dump::create
{
struct QuotaExceeded;
} // namespace sdbusplus::error::xyz::openbmc_project::dump::create
namespace sdbusplus::error::xyz::openbmc_project::hardware_isolation
{
struct IsolatedAlready;
} // namespace sdbusplus::error::xyz::openbmc_project::hardware_isolation
namespace sdbusplus::error::xyz::openbmc_project::inventory
{
struct Nonfunctional;
} // namespace sdbusplus::error::xyz::openbmc_project::inventory
namespace sdbusplus::error::xyz::openbmc_project::inventory
{
struct NotPresent;
} // namespace sdbusplus::error::xyz::openbmc_project::inventory
namespace sdbusplus::error::xyz::openbmc_project::logging::sel
{
struct Created;
} // namespace sdbusplus::error::xyz::openbmc_project::logging::sel
namespace sdbusplus::error::xyz::openbmc_project::memory::memory_ecc
{
struct CeCount;
} // namespace sdbusplus::error::xyz::openbmc_project::memory::memory_ecc
namespace sdbusplus::error::xyz::openbmc_project::memory::memory_ecc
{
struct IsLoggingLimitReached;
} // namespace sdbusplus::error::xyz::openbmc_project::memory::memory_ecc
namespace sdbusplus::error::xyz::openbmc_project::memory::memory_ecc
{
struct UeCount;
} // namespace sdbusplus::error::xyz::openbmc_project::memory::memory_ecc
namespace sdbusplus::error::xyz::openbmc_project::nvme::status
{
struct BackupDeviceFault;
} // namespace sdbusplus::error::xyz::openbmc_project::nvme::status
namespace sdbusplus::error::xyz::openbmc_project::nvme::status
{
struct CapacityFault;
} // namespace sdbusplus::error::xyz::openbmc_project::nvme::status
namespace sdbusplus::error::xyz::openbmc_project::nvme::status
{
struct DegradesFault;
} // namespace sdbusplus::error::xyz::openbmc_project::nvme::status
namespace sdbusplus::error::xyz::openbmc_project::nvme::status
{
struct MediaFault;
} // namespace sdbusplus::error::xyz::openbmc_project::nvme::status
namespace sdbusplus::error::xyz::openbmc_project::nvme::status
{
struct TemperatureFault;
} // namespace sdbusplus::error::xyz::openbmc_project::nvme::status
namespace sdbusplus::error::xyz::openbmc_project::scheduled_time
{
struct InvalidTime;
} // namespace sdbusplus::error::xyz::openbmc_project::scheduled_time
namespace sdbusplus::error::xyz::openbmc_project::sensor::device
{
struct ReadFailure;
} // namespace sdbusplus::error::xyz::openbmc_project::sensor::device
namespace sdbusplus::error::xyz::openbmc_project::sensor::threshold
{
struct CriticalHigh;
} // namespace sdbusplus::error::xyz::openbmc_project::sensor::threshold
namespace sdbusplus::error::xyz::openbmc_project::sensor::threshold
{
struct CriticalLow;
} // namespace sdbusplus::error::xyz::openbmc_project::sensor::threshold
namespace sdbusplus::error::xyz::openbmc_project::smbios::mdr_v2
{
struct InvalidId;
} // namespace sdbusplus::error::xyz::openbmc_project::smbios::mdr_v2
namespace sdbusplus::error::xyz::openbmc_project::smbios::mdr_v2
{
struct InvalidParameter;
} // namespace sdbusplus::error::xyz::openbmc_project::smbios::mdr_v2
namespace sdbusplus::error::xyz::openbmc_project::smbios::mdr_v2
{
struct UpdateInProgress;
} // namespace sdbusplus::error::xyz::openbmc_project::smbios::mdr_v2
namespace sdbusplus::error::xyz::openbmc_project::software::version
{
struct AlreadyExists;
} // namespace sdbusplus::error::xyz::openbmc_project::software::version
namespace sdbusplus::error::xyz::openbmc_project::software::version
{
struct Incompatible;
} // namespace sdbusplus::error::xyz::openbmc_project::software::version
namespace sdbusplus::error::xyz::openbmc_project::software::version
{
struct InvalidSignature;
} // namespace sdbusplus::error::xyz::openbmc_project::software::version
namespace sdbusplus::error::xyz::openbmc_project::state::bmc
{
struct MultiUserTargetFailure;
} // namespace sdbusplus::error::xyz::openbmc_project::state::bmc
namespace sdbusplus::error::xyz::openbmc_project::state::chassis
{
struct BMCNotReady;
} // namespace sdbusplus::error::xyz::openbmc_project::state::chassis
namespace sdbusplus::error::xyz::openbmc_project::state::chassis
{
struct PowerCycleFailure;
} // namespace sdbusplus::error::xyz::openbmc_project::state::chassis
namespace sdbusplus::error::xyz::openbmc_project::state::chassis
{
struct PowerOffFailure;
} // namespace sdbusplus::error::xyz::openbmc_project::state::chassis
namespace sdbusplus::error::xyz::openbmc_project::state::chassis
{
struct PowerOnFailure;
} // namespace sdbusplus::error::xyz::openbmc_project::state::chassis
namespace sdbusplus::error::xyz::openbmc_project::state::host
{
struct BMCNotReady;
} // namespace sdbusplus::error::xyz::openbmc_project::state::host
namespace sdbusplus::error::xyz::openbmc_project::state::host
{
struct HostMinStartFailure;
} // namespace sdbusplus::error::xyz::openbmc_project::state::host
namespace sdbusplus::error::xyz::openbmc_project::state::host
{
struct HostRebootFailure;
} // namespace sdbusplus::error::xyz::openbmc_project::state::host
namespace sdbusplus::error::xyz::openbmc_project::state::host
{
struct HostShutdownFailure;
} // namespace sdbusplus::error::xyz::openbmc_project::state::host
namespace sdbusplus::error::xyz::openbmc_project::state::host
{
struct HostStartFailure;
} // namespace sdbusplus::error::xyz::openbmc_project::state::host
namespace sdbusplus::error::xyz::openbmc_project::state::host
{
struct HostStopFailure;
} // namespace sdbusplus::error::xyz::openbmc_project::state::host
namespace sdbusplus::error::xyz::openbmc_project::state::host
{
struct SoftOffTimeout;
} // namespace sdbusplus::error::xyz::openbmc_project::state::host
namespace sdbusplus::error::xyz::openbmc_project::state::shutdown::inventory
{
struct Fan;
} // namespace sdbusplus::error::xyz::openbmc_project::state::shutdown::inventory
namespace sdbusplus::error::xyz::openbmc_project::state::shutdown::power
{
struct Blackout;
} // namespace sdbusplus::error::xyz::openbmc_project::state::shutdown::power
namespace sdbusplus::error::xyz::openbmc_project::state::shutdown::power
{
struct Fault;
} // namespace sdbusplus::error::xyz::openbmc_project::state::shutdown::power
namespace sdbusplus::error::xyz::openbmc_project::state::shutdown::power
{
struct Regulator;
} // namespace sdbusplus::error::xyz::openbmc_project::state::shutdown::power
namespace sdbusplus::error::xyz::openbmc_project::state::shutdown::thermal_event
{
struct Ambient;
} // namespace sdbusplus::error::xyz::openbmc_project::state::shutdown::thermal_event
namespace sdbusplus::error::xyz::openbmc_project::state::shutdown::thermal_event
{
struct GPU;
} // namespace sdbusplus::error::xyz::openbmc_project::state::shutdown::thermal_event
namespace sdbusplus::error::xyz::openbmc_project::state::shutdown::thermal_event
{
struct Processor;
} // namespace sdbusplus::error::xyz::openbmc_project::state::shutdown::thermal_event
namespace sdbusplus::error::xyz::openbmc_project::state::systemd_target
{
struct Failure;
} // namespace sdbusplus::error::xyz::openbmc_project::state::systemd_target
namespace sdbusplus::error::xyz::openbmc_project::time
{
struct Failed;
} // namespace sdbusplus::error::xyz::openbmc_project::time
namespace sdbusplus::error::xyz::openbmc_project::time
{
struct NotAllowed;
} // namespace sdbusplus::error::xyz::openbmc_project::time
namespace sdbusplus::error::xyz::openbmc_project::user::common
{
struct GroupNameDoesNotExist;
} // namespace sdbusplus::error::xyz::openbmc_project::user::common
namespace sdbusplus::error::xyz::openbmc_project::user::common
{
struct GroupNameExists;
} // namespace sdbusplus::error::xyz::openbmc_project::user::common
namespace sdbusplus::error::xyz::openbmc_project::user::common
{
struct NoResource;
} // namespace sdbusplus::error::xyz::openbmc_project::user::common
namespace sdbusplus::error::xyz::openbmc_project::user::common
{
struct PrivilegeMappingExists;
} // namespace sdbusplus::error::xyz::openbmc_project::user::common
namespace sdbusplus::error::xyz::openbmc_project::user::common
{
struct UserNameDoesNotExist;
} // namespace sdbusplus::error::xyz::openbmc_project::user::common
namespace sdbusplus::error::xyz::openbmc_project::user::common
{
struct UserNameExists;
} // namespace sdbusplus::error::xyz::openbmc_project::user::common
namespace sdbusplus::error::xyz::openbmc_project::user::common
{
struct UserNameGroupFail;
} // namespace sdbusplus::error::xyz::openbmc_project::user::common
namespace sdbusplus::error::xyz::openbmc_project::user::common
{
struct UserNamePrivFail;
} // namespace sdbusplus::error::xyz::openbmc_project::user::common

namespace phosphor::logging
{

namespace org::open_power::common::callout
{
namespace _Procedure
{
struct PROCEDURE
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PROCEDURE";
    using type = std::tuple<std::decay_t<decltype("PROCEDURE=%u")>,uint32_t>;
    explicit constexpr PROCEDURE(uint32_t a) : _entry(entry("PROCEDURE=%u", a)) {};
    type _entry;
};
} // namespace _Procedure

struct Procedure
{
    static constexpr auto L = level::ERR;
    using PROCEDURE = _Procedure::PROCEDURE;
    using metadata_types = std::tuple<PROCEDURE>;
};

} // namespace org::open_power::common::callout

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace org::open_power::Common::Callout
{
using Procedure =
    phosphor::logging::org::open_power::common::callout::Procedure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::org::open_power::common::callout::Procedure>
{
    using type =
        phosphor::logging::org::open_power::common::callout::Procedure;
};

} // namespace details
namespace org::open_power::proc::fsi
{
namespace _SlaveDetectionFailure
{
struct ERRNO
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype("ERRNO=%d")>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry("ERRNO=%d", a)) {};
    type _entry;
};
} // namespace _SlaveDetectionFailure

struct SlaveDetectionFailure
{
    static constexpr auto L = level::ERR;
    using ERRNO = _SlaveDetectionFailure::ERRNO;
    using metadata_types = std::tuple<ERRNO>;
};

} // namespace org::open_power::proc::fsi

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace org::open_power::Proc::FSI
{
using SlaveDetectionFailure =
    phosphor::logging::org::open_power::proc::fsi::SlaveDetectionFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::org::open_power::proc::fsi::SlaveDetectionFailure>
{
    using type =
        phosphor::logging::org::open_power::proc::fsi::SlaveDetectionFailure;
};

} // namespace details
namespace org::open_power::host::boot
{

struct Checkstop
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace org::open_power::host::boot

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace org::open_power::Host::Boot
{
using Checkstop =
    phosphor::logging::org::open_power::host::boot::Checkstop;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::org::open_power::host::boot::Checkstop>
{
    using type =
        phosphor::logging::org::open_power::host::boot::Checkstop;
};

} // namespace details
namespace org::open_power::host::boot
{

struct WatchdogTimedOut
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace org::open_power::host::boot

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace org::open_power::Host::Boot
{
using WatchdogTimedOut =
    phosphor::logging::org::open_power::host::boot::WatchdogTimedOut;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::org::open_power::host::boot::WatchdogTimedOut>
{
    using type =
        phosphor::logging::org::open_power::host::boot::WatchdogTimedOut;
};

} // namespace details
namespace com::google::gbmc::hoth
{

struct CommandFailure
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::google::gbmc::hoth

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::google::gbmc::Hoth
{
using CommandFailure =
    phosphor::logging::com::google::gbmc::hoth::CommandFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::google::gbmc::hoth::CommandFailure>
{
    using type =
        phosphor::logging::com::google::gbmc::hoth::CommandFailure;
};

} // namespace details
namespace com::google::gbmc::hoth
{

struct ResponseFailure
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::google::gbmc::hoth

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::google::gbmc::Hoth
{
using ResponseFailure =
    phosphor::logging::com::google::gbmc::hoth::ResponseFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::google::gbmc::hoth::ResponseFailure>
{
    using type =
        phosphor::logging::com::google::gbmc::hoth::ResponseFailure;
};

} // namespace details
namespace com::google::gbmc::hoth
{

struct FirmwareFailure
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::google::gbmc::hoth

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::google::gbmc::Hoth
{
using FirmwareFailure =
    phosphor::logging::com::google::gbmc::hoth::FirmwareFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::google::gbmc::hoth::FirmwareFailure>
{
    using type =
        phosphor::logging::com::google::gbmc::hoth::FirmwareFailure;
};

} // namespace details
namespace com::google::gbmc::hoth
{

struct ResponseNotFound
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::google::gbmc::hoth

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::google::gbmc::Hoth
{
using ResponseNotFound =
    phosphor::logging::com::google::gbmc::hoth::ResponseNotFound;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::google::gbmc::hoth::ResponseNotFound>
{
    using type =
        phosphor::logging::com::google::gbmc::hoth::ResponseNotFound;
};

} // namespace details
namespace com::google::gbmc::hoth
{

struct InterfaceError
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::google::gbmc::hoth

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::google::gbmc::Hoth
{
using InterfaceError =
    phosphor::logging::com::google::gbmc::hoth::InterfaceError;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::google::gbmc::hoth::InterfaceError>
{
    using type =
        phosphor::logging::com::google::gbmc::hoth::InterfaceError;
};

} // namespace details
namespace com::google::gbmc::hoth
{

struct ExpectedInfoNotFound
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::google::gbmc::hoth

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::google::gbmc::Hoth
{
using ExpectedInfoNotFound =
    phosphor::logging::com::google::gbmc::hoth::ExpectedInfoNotFound;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::google::gbmc::hoth::ExpectedInfoNotFound>
{
    using type =
        phosphor::logging::com::google::gbmc::hoth::ExpectedInfoNotFound;
};

} // namespace details
namespace com::ibm::vpd
{

struct LocationNotFound
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::ibm::vpd

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::ibm::VPD
{
using LocationNotFound =
    phosphor::logging::com::ibm::vpd::LocationNotFound;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::ibm::vpd::LocationNotFound>
{
    using type =
        phosphor::logging::com::ibm::vpd::LocationNotFound;
};

} // namespace details
namespace com::ibm::vpd
{

struct NodeNotFound
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::ibm::vpd

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::ibm::VPD
{
using NodeNotFound =
    phosphor::logging::com::ibm::vpd::NodeNotFound;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::ibm::vpd::NodeNotFound>
{
    using type =
        phosphor::logging::com::ibm::vpd::NodeNotFound;
};

} // namespace details
namespace com::ibm::vpd
{

struct PathNotFound
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::ibm::vpd

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::ibm::VPD
{
using PathNotFound =
    phosphor::logging::com::ibm::vpd::PathNotFound;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::ibm::vpd::PathNotFound>
{
    using type =
        phosphor::logging::com::ibm::vpd::PathNotFound;
};

} // namespace details
namespace com::ibm::vpd
{

struct RecordNotFound
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::ibm::vpd

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::ibm::VPD
{
using RecordNotFound =
    phosphor::logging::com::ibm::vpd::RecordNotFound;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::ibm::vpd::RecordNotFound>
{
    using type =
        phosphor::logging::com::ibm::vpd::RecordNotFound;
};

} // namespace details
namespace com::ibm::vpd
{

struct KeywordNotFound
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::ibm::vpd

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::ibm::VPD
{
using KeywordNotFound =
    phosphor::logging::com::ibm::vpd::KeywordNotFound;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::ibm::vpd::KeywordNotFound>
{
    using type =
        phosphor::logging::com::ibm::vpd::KeywordNotFound;
};

} // namespace details
namespace com::ibm::vpd
{

struct BlankSystemVPD
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::ibm::vpd

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::ibm::VPD
{
using BlankSystemVPD =
    phosphor::logging::com::ibm::vpd::BlankSystemVPD;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::ibm::vpd::BlankSystemVPD>
{
    using type =
        phosphor::logging::com::ibm::vpd::BlankSystemVPD;
};

} // namespace details
namespace com::ibm::vpd
{

struct InvalidEepromPath
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::ibm::vpd

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::ibm::VPD
{
using InvalidEepromPath =
    phosphor::logging::com::ibm::vpd::InvalidEepromPath;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::ibm::vpd::InvalidEepromPath>
{
    using type =
        phosphor::logging::com::ibm::vpd::InvalidEepromPath;
};

} // namespace details
namespace com::ibm::vpd
{

struct InvalidVPD
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::ibm::vpd

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::ibm::VPD
{
using InvalidVPD =
    phosphor::logging::com::ibm::vpd::InvalidVPD;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::ibm::vpd::InvalidVPD>
{
    using type =
        phosphor::logging::com::ibm::vpd::InvalidVPD;
};

} // namespace details
namespace com::ibm::vpd
{

struct EccCheckFailed
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::ibm::vpd

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::ibm::VPD
{
using EccCheckFailed =
    phosphor::logging::com::ibm::vpd::EccCheckFailed;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::ibm::vpd::EccCheckFailed>
{
    using type =
        phosphor::logging::com::ibm::vpd::EccCheckFailed;
};

} // namespace details
namespace com::ibm::vpd
{

struct InvalidJson
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::ibm::vpd

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::ibm::VPD
{
using InvalidJson =
    phosphor::logging::com::ibm::vpd::InvalidJson;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::ibm::vpd::InvalidJson>
{
    using type =
        phosphor::logging::com::ibm::vpd::InvalidJson;
};

} // namespace details
namespace com::ibm::vpd
{

struct DbusFailure
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace com::ibm::vpd

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace com::ibm::VPD
{
using DbusFailure =
    phosphor::logging::com::ibm::vpd::DbusFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::com::ibm::vpd::DbusFailure>
{
    using type =
        phosphor::logging::com::ibm::vpd::DbusFailure;
};

} // namespace details
namespace xyz::openbmc_project::common
{
namespace _Timeout
{
struct TIMEOUT_IN_MSEC
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "TIMEOUT_IN_MSEC";
    using type = std::tuple<std::decay_t<decltype("TIMEOUT_IN_MSEC=%llu")>,uint64_t>;
    explicit constexpr TIMEOUT_IN_MSEC(uint64_t a) : _entry(entry("TIMEOUT_IN_MSEC=%llu", a)) {};
    type _entry;
};
} // namespace _Timeout

struct Timeout
{
    static constexpr auto L = level::ERR;
    using TIMEOUT_IN_MSEC = _Timeout::TIMEOUT_IN_MSEC;
    using metadata_types = std::tuple<TIMEOUT_IN_MSEC>;
};

} // namespace xyz::openbmc_project::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common
{
using Timeout =
    phosphor::logging::xyz::openbmc_project::common::Timeout;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::Timeout>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::Timeout;
};

} // namespace details
namespace xyz::openbmc_project::common
{

struct InternalFailure
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common
{
using InternalFailure =
    phosphor::logging::xyz::openbmc_project::common::InternalFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::InternalFailure>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::InternalFailure;
};

} // namespace details
namespace xyz::openbmc_project::common
{
namespace _InvalidArgument
{
struct ARGUMENT_NAME
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ARGUMENT_NAME";
    using type = std::tuple<std::decay_t<decltype("ARGUMENT_NAME=%s")>,const char*>;
    explicit constexpr ARGUMENT_NAME(const char* a) : _entry(entry("ARGUMENT_NAME=%s", a)) {};
    type _entry;
};
struct ARGUMENT_VALUE
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ARGUMENT_VALUE";
    using type = std::tuple<std::decay_t<decltype("ARGUMENT_VALUE=%s")>,const char*>;
    explicit constexpr ARGUMENT_VALUE(const char* a) : _entry(entry("ARGUMENT_VALUE=%s", a)) {};
    type _entry;
};
} // namespace _InvalidArgument

struct InvalidArgument
{
    static constexpr auto L = level::ERR;
    using ARGUMENT_NAME = _InvalidArgument::ARGUMENT_NAME;
    using ARGUMENT_VALUE = _InvalidArgument::ARGUMENT_VALUE;
    using metadata_types = std::tuple<ARGUMENT_NAME, ARGUMENT_VALUE>;
};

} // namespace xyz::openbmc_project::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common
{
using InvalidArgument =
    phosphor::logging::xyz::openbmc_project::common::InvalidArgument;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::InvalidArgument>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::InvalidArgument;
};

} // namespace details
namespace xyz::openbmc_project::common
{

struct InsufficientPermission
{
    static constexpr auto L = level::INFO;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common
{
using InsufficientPermission =
    phosphor::logging::xyz::openbmc_project::common::InsufficientPermission;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::InsufficientPermission>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::InsufficientPermission;
};

} // namespace details
namespace xyz::openbmc_project::common
{
namespace _NotAllowed
{
struct REASON
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON";
    using type = std::tuple<std::decay_t<decltype("REASON=%s")>,const char*>;
    explicit constexpr REASON(const char* a) : _entry(entry("REASON=%s", a)) {};
    type _entry;
};
} // namespace _NotAllowed

struct NotAllowed
{
    static constexpr auto L = level::INFO;
    using REASON = _NotAllowed::REASON;
    using metadata_types = std::tuple<REASON>;
};

} // namespace xyz::openbmc_project::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common
{
using NotAllowed =
    phosphor::logging::xyz::openbmc_project::common::NotAllowed;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::NotAllowed>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::NotAllowed;
};

} // namespace details
namespace xyz::openbmc_project::common
{

struct NoCACertificate
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common
{
using NoCACertificate =
    phosphor::logging::xyz::openbmc_project::common::NoCACertificate;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::NoCACertificate>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::NoCACertificate;
};

} // namespace details
namespace xyz::openbmc_project::common
{

struct TooManyResources
{
    static constexpr auto L = level::INFO;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common
{
using TooManyResources =
    phosphor::logging::xyz::openbmc_project::common::TooManyResources;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::TooManyResources>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::TooManyResources;
};

} // namespace details
namespace xyz::openbmc_project::common
{
namespace _ResourceNotFound
{
struct RESOURCE
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "RESOURCE";
    using type = std::tuple<std::decay_t<decltype("RESOURCE=%s")>,const char*>;
    explicit constexpr RESOURCE(const char* a) : _entry(entry("RESOURCE=%s", a)) {};
    type _entry;
};
} // namespace _ResourceNotFound

struct ResourceNotFound
{
    static constexpr auto L = level::INFO;
    using RESOURCE = _ResourceNotFound::RESOURCE;
    using metadata_types = std::tuple<RESOURCE>;
};

} // namespace xyz::openbmc_project::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common
{
using ResourceNotFound =
    phosphor::logging::xyz::openbmc_project::common::ResourceNotFound;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::ResourceNotFound>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::ResourceNotFound;
};

} // namespace details
namespace xyz::openbmc_project::common
{

struct Unavailable
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common
{
using Unavailable =
    phosphor::logging::xyz::openbmc_project::common::Unavailable;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::Unavailable>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::Unavailable;
};

} // namespace details
namespace xyz::openbmc_project::common
{
namespace _UnsupportedRequest
{
struct REASON
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON";
    using type = std::tuple<std::decay_t<decltype("REASON=%s")>,const char*>;
    explicit constexpr REASON(const char* a) : _entry(entry("REASON=%s", a)) {};
    type _entry;
};
} // namespace _UnsupportedRequest

struct UnsupportedRequest
{
    static constexpr auto L = level::INFO;
    using REASON = _UnsupportedRequest::REASON;
    using metadata_types = std::tuple<REASON>;
};

} // namespace xyz::openbmc_project::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common
{
using UnsupportedRequest =
    phosphor::logging::xyz::openbmc_project::common::UnsupportedRequest;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::UnsupportedRequest>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::UnsupportedRequest;
};

} // namespace details
namespace xyz::openbmc_project::certs
{
namespace _InvalidCertificate
{
struct REASON
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON";
    using type = std::tuple<std::decay_t<decltype("REASON=%s")>,const char*>;
    explicit constexpr REASON(const char* a) : _entry(entry("REASON=%s", a)) {};
    type _entry;
};
} // namespace _InvalidCertificate

struct InvalidCertificate
{
    static constexpr auto L = level::ERR;
    using REASON = _InvalidCertificate::REASON;
    using metadata_types = std::tuple<REASON>;
};

} // namespace xyz::openbmc_project::certs

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Certs
{
using InvalidCertificate =
    phosphor::logging::xyz::openbmc_project::certs::InvalidCertificate;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::certs::InvalidCertificate>
{
    using type =
        phosphor::logging::xyz::openbmc_project::certs::InvalidCertificate;
};

} // namespace details
namespace xyz::openbmc_project::hardware_isolation
{

struct IsolatedAlready
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::hardware_isolation

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::HardwareIsolation
{
using IsolatedAlready =
    phosphor::logging::xyz::openbmc_project::hardware_isolation::IsolatedAlready;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::hardware_isolation::IsolatedAlready>
{
    using type =
        phosphor::logging::xyz::openbmc_project::hardware_isolation::IsolatedAlready;
};

} // namespace details
namespace xyz::openbmc_project::scheduled_time
{
namespace _InvalidTime
{
struct REASON
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON";
    using type = std::tuple<std::decay_t<decltype("REASON=%s")>,const char*>;
    explicit constexpr REASON(const char* a) : _entry(entry("REASON=%s", a)) {};
    type _entry;
};
} // namespace _InvalidTime

struct InvalidTime
{
    static constexpr auto L = level::ERR;
    using REASON = _InvalidTime::REASON;
    using metadata_types = std::tuple<REASON>;
};

} // namespace xyz::openbmc_project::scheduled_time

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::ScheduledTime
{
using InvalidTime =
    phosphor::logging::xyz::openbmc_project::scheduled_time::InvalidTime;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::scheduled_time::InvalidTime>
{
    using type =
        phosphor::logging::xyz::openbmc_project::scheduled_time::InvalidTime;
};

} // namespace details
namespace xyz::openbmc_project::control::host
{

struct CommandNotSupported
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::control::host

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Control::Host
{
using CommandNotSupported =
    phosphor::logging::xyz::openbmc_project::control::host::CommandNotSupported;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::control::host::CommandNotSupported>
{
    using type =
        phosphor::logging::xyz::openbmc_project::control::host::CommandNotSupported;
};

} // namespace details
namespace xyz::openbmc_project::common::callout
{
namespace _Device
{
struct CALLOUT_ERRNO
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_ERRNO";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_ERRNO=%d")>,int32_t>;
    explicit constexpr CALLOUT_ERRNO(int32_t a) : _entry(entry("CALLOUT_ERRNO=%d", a)) {};
    type _entry;
};
struct CALLOUT_DEVICE_PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_DEVICE_PATH";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_DEVICE_PATH=%s")>,const char*>;
    explicit constexpr CALLOUT_DEVICE_PATH(const char* a) : _entry(entry("CALLOUT_DEVICE_PATH=%s", a)) {};
    type _entry;
};
} // namespace _Device

struct Device
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO = _Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = _Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;
};

} // namespace xyz::openbmc_project::common::callout

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common::Callout
{
using Device =
    phosphor::logging::xyz::openbmc_project::common::callout::Device;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::callout::Device>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::callout::Device;
};

} // namespace details
namespace xyz::openbmc_project::common::callout
{
namespace _GPIO
{
struct CALLOUT_GPIO_NUM
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_GPIO_NUM";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_GPIO_NUM=%u")>,uint32_t>;
    explicit constexpr CALLOUT_GPIO_NUM(uint32_t a) : _entry(entry("CALLOUT_GPIO_NUM=%u", a)) {};
    type _entry;
};
} // namespace _GPIO

struct GPIO
{
    static constexpr auto L = level::ERR;
    using CALLOUT_GPIO_NUM = _GPIO::CALLOUT_GPIO_NUM;
    using CALLOUT_ERRNO =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_GPIO_NUM, CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;
};

} // namespace xyz::openbmc_project::common::callout

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common::Callout
{
using GPIO =
    phosphor::logging::xyz::openbmc_project::common::callout::GPIO;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::callout::GPIO>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::callout::GPIO;
};

} // namespace details
namespace xyz::openbmc_project::common::callout
{
namespace _IIC
{
struct CALLOUT_IIC_BUS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_IIC_BUS";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_IIC_BUS=%s")>,const char*>;
    explicit constexpr CALLOUT_IIC_BUS(const char* a) : _entry(entry("CALLOUT_IIC_BUS=%s", a)) {};
    type _entry;
};
struct CALLOUT_IIC_ADDR
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_IIC_ADDR";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_IIC_ADDR=0x%hx")>,uint16_t>;
    explicit constexpr CALLOUT_IIC_ADDR(uint16_t a) : _entry(entry("CALLOUT_IIC_ADDR=0x%hx", a)) {};
    type _entry;
};
} // namespace _IIC

struct IIC
{
    static constexpr auto L = level::ERR;
    using CALLOUT_IIC_BUS = _IIC::CALLOUT_IIC_BUS;
    using CALLOUT_IIC_ADDR = _IIC::CALLOUT_IIC_ADDR;
    using CALLOUT_ERRNO =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_IIC_BUS, CALLOUT_IIC_ADDR, CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;
};

} // namespace xyz::openbmc_project::common::callout

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common::Callout
{
using IIC =
    phosphor::logging::xyz::openbmc_project::common::callout::IIC;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::callout::IIC>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::callout::IIC;
};

} // namespace details
namespace xyz::openbmc_project::common::callout
{
namespace _Inventory
{
struct CALLOUT_INVENTORY_PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_INVENTORY_PATH";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_INVENTORY_PATH=%s")>,const char*>;
    explicit constexpr CALLOUT_INVENTORY_PATH(const char* a) : _entry(entry("CALLOUT_INVENTORY_PATH=%s", a)) {};
    type _entry;
};
} // namespace _Inventory

struct Inventory
{
    static constexpr auto L = level::ERR;
    using CALLOUT_INVENTORY_PATH = _Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<CALLOUT_INVENTORY_PATH>;
};

} // namespace xyz::openbmc_project::common::callout

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common::Callout
{
using Inventory =
    phosphor::logging::xyz::openbmc_project::common::callout::Inventory;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::callout::Inventory>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::callout::Inventory;
};

} // namespace details
namespace xyz::openbmc_project::common::callout
{
namespace _IPMISensor
{
struct CALLOUT_IPMI_SENSOR_NUM
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_IPMI_SENSOR_NUM";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_IPMI_SENSOR_NUM=%u")>,uint32_t>;
    explicit constexpr CALLOUT_IPMI_SENSOR_NUM(uint32_t a) : _entry(entry("CALLOUT_IPMI_SENSOR_NUM=%u", a)) {};
    type _entry;
};
} // namespace _IPMISensor

struct IPMISensor
{
    static constexpr auto L = level::ERR;
    using CALLOUT_IPMI_SENSOR_NUM = _IPMISensor::CALLOUT_IPMI_SENSOR_NUM;
    using metadata_types = std::tuple<CALLOUT_IPMI_SENSOR_NUM>;
};

} // namespace xyz::openbmc_project::common::callout

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common::Callout
{
using IPMISensor =
    phosphor::logging::xyz::openbmc_project::common::callout::IPMISensor;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::callout::IPMISensor>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::callout::IPMISensor;
};

} // namespace details
namespace xyz::openbmc_project::common::device
{

struct ReadFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;
};

} // namespace xyz::openbmc_project::common::device

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common::Device
{
using ReadFailure =
    phosphor::logging::xyz::openbmc_project::common::device::ReadFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::device::ReadFailure>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::device::ReadFailure;
};

} // namespace details
namespace xyz::openbmc_project::common::device
{

struct WriteFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;
};

} // namespace xyz::openbmc_project::common::device

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common::Device
{
using WriteFailure =
    phosphor::logging::xyz::openbmc_project::common::device::WriteFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::device::WriteFailure>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::device::WriteFailure;
};

} // namespace details
namespace xyz::openbmc_project::common::file
{
namespace _Open
{
struct ERRNO
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype("ERRNO=%d")>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry("ERRNO=%d", a)) {};
    type _entry;
};
struct PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype("PATH=%s")>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry("PATH=%s", a)) {};
    type _entry;
};
} // namespace _Open

struct Open
{
    static constexpr auto L = level::ERR;
    using ERRNO = _Open::ERRNO;
    using PATH = _Open::PATH;
    using metadata_types = std::tuple<ERRNO, PATH>;
};

} // namespace xyz::openbmc_project::common::file

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common::File
{
using Open =
    phosphor::logging::xyz::openbmc_project::common::file::Open;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::file::Open>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::file::Open;
};

} // namespace details
namespace xyz::openbmc_project::common::file
{
namespace _Seek
{
struct OFFSET
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "OFFSET";
    using type = std::tuple<std::decay_t<decltype("OFFSET=%ll")>,int64_t>;
    explicit constexpr OFFSET(int64_t a) : _entry(entry("OFFSET=%ll", a)) {};
    type _entry;
};
struct WHENCE
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "WHENCE";
    using type = std::tuple<std::decay_t<decltype("WHENCE=%d")>,int32_t>;
    explicit constexpr WHENCE(int32_t a) : _entry(entry("WHENCE=%d", a)) {};
    type _entry;
};
struct ERRNO
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype("ERRNO=%d")>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry("ERRNO=%d", a)) {};
    type _entry;
};
struct PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype("PATH=%s")>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry("PATH=%s", a)) {};
    type _entry;
};
} // namespace _Seek

struct Seek
{
    static constexpr auto L = level::ERR;
    using OFFSET = _Seek::OFFSET;
    using WHENCE = _Seek::WHENCE;
    using ERRNO = _Seek::ERRNO;
    using PATH = _Seek::PATH;
    using metadata_types = std::tuple<OFFSET, WHENCE, ERRNO, PATH>;
};

} // namespace xyz::openbmc_project::common::file

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common::File
{
using Seek =
    phosphor::logging::xyz::openbmc_project::common::file::Seek;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::file::Seek>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::file::Seek;
};

} // namespace details
namespace xyz::openbmc_project::common::file
{
namespace _Write
{
struct ERRNO
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype("ERRNO=%d")>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry("ERRNO=%d", a)) {};
    type _entry;
};
struct PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype("PATH=%s")>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry("PATH=%s", a)) {};
    type _entry;
};
} // namespace _Write

struct Write
{
    static constexpr auto L = level::ERR;
    using ERRNO = _Write::ERRNO;
    using PATH = _Write::PATH;
    using metadata_types = std::tuple<ERRNO, PATH>;
};

} // namespace xyz::openbmc_project::common::file

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common::File
{
using Write =
    phosphor::logging::xyz::openbmc_project::common::file::Write;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::file::Write>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::file::Write;
};

} // namespace details
namespace xyz::openbmc_project::common::file
{
namespace _Read
{
struct ERRNO
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype("ERRNO=%d")>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry("ERRNO=%d", a)) {};
    type _entry;
};
struct PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype("PATH=%s")>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry("PATH=%s", a)) {};
    type _entry;
};
} // namespace _Read

struct Read
{
    static constexpr auto L = level::ERR;
    using ERRNO = _Read::ERRNO;
    using PATH = _Read::PATH;
    using metadata_types = std::tuple<ERRNO, PATH>;
};

} // namespace xyz::openbmc_project::common::file

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Common::File
{
using Read =
    phosphor::logging::xyz::openbmc_project::common::file::Read;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::common::file::Read>
{
    using type =
        phosphor::logging::xyz::openbmc_project::common::file::Read;
};

} // namespace details
namespace xyz::openbmc_project::bios_config::common
{

struct AttributeNotFound
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::bios_config::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::BIOSConfig::Common
{
using AttributeNotFound =
    phosphor::logging::xyz::openbmc_project::bios_config::common::AttributeNotFound;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::bios_config::common::AttributeNotFound>
{
    using type =
        phosphor::logging::xyz::openbmc_project::bios_config::common::AttributeNotFound;
};

} // namespace details
namespace xyz::openbmc_project::bios_config::common
{
namespace _AttributeReadOnly
{
struct REASON
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON";
    using type = std::tuple<std::decay_t<decltype("REASON=%s")>,const char*>;
    explicit constexpr REASON(const char* a) : _entry(entry("REASON=%s", a)) {};
    type _entry;
};
} // namespace _AttributeReadOnly

struct AttributeReadOnly
{
    static constexpr auto L = level::ERR;
    using REASON = _AttributeReadOnly::REASON;
    using metadata_types = std::tuple<REASON>;
};

} // namespace xyz::openbmc_project::bios_config::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::BIOSConfig::Common
{
using AttributeReadOnly =
    phosphor::logging::xyz::openbmc_project::bios_config::common::AttributeReadOnly;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::bios_config::common::AttributeReadOnly>
{
    using type =
        phosphor::logging::xyz::openbmc_project::bios_config::common::AttributeReadOnly;
};

} // namespace details
namespace xyz::openbmc_project::bios_config::common
{

struct InvalidCurrentPassword
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::bios_config::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::BIOSConfig::Common
{
using InvalidCurrentPassword =
    phosphor::logging::xyz::openbmc_project::bios_config::common::InvalidCurrentPassword;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::bios_config::common::InvalidCurrentPassword>
{
    using type =
        phosphor::logging::xyz::openbmc_project::bios_config::common::InvalidCurrentPassword;
};

} // namespace details
namespace xyz::openbmc_project::bios_config::common
{

struct PasswordNotSettable
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::bios_config::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::BIOSConfig::Common
{
using PasswordNotSettable =
    phosphor::logging::xyz::openbmc_project::bios_config::common::PasswordNotSettable;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::bios_config::common::PasswordNotSettable>
{
    using type =
        phosphor::logging::xyz::openbmc_project::bios_config::common::PasswordNotSettable;
};

} // namespace details
namespace xyz::openbmc_project::nvme::status
{

struct CapacityFault
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::nvme::status

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Nvme::Status
{
using CapacityFault =
    phosphor::logging::xyz::openbmc_project::nvme::status::CapacityFault;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::nvme::status::CapacityFault>
{
    using type =
        phosphor::logging::xyz::openbmc_project::nvme::status::CapacityFault;
};

} // namespace details
namespace xyz::openbmc_project::nvme::status
{

struct TemperatureFault
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::nvme::status

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Nvme::Status
{
using TemperatureFault =
    phosphor::logging::xyz::openbmc_project::nvme::status::TemperatureFault;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::nvme::status::TemperatureFault>
{
    using type =
        phosphor::logging::xyz::openbmc_project::nvme::status::TemperatureFault;
};

} // namespace details
namespace xyz::openbmc_project::nvme::status
{

struct DegradesFault
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::nvme::status

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Nvme::Status
{
using DegradesFault =
    phosphor::logging::xyz::openbmc_project::nvme::status::DegradesFault;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::nvme::status::DegradesFault>
{
    using type =
        phosphor::logging::xyz::openbmc_project::nvme::status::DegradesFault;
};

} // namespace details
namespace xyz::openbmc_project::nvme::status
{

struct MediaFault
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::nvme::status

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Nvme::Status
{
using MediaFault =
    phosphor::logging::xyz::openbmc_project::nvme::status::MediaFault;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::nvme::status::MediaFault>
{
    using type =
        phosphor::logging::xyz::openbmc_project::nvme::status::MediaFault;
};

} // namespace details
namespace xyz::openbmc_project::nvme::status
{

struct BackupDeviceFault
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::nvme::status

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Nvme::Status
{
using BackupDeviceFault =
    phosphor::logging::xyz::openbmc_project::nvme::status::BackupDeviceFault;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::nvme::status::BackupDeviceFault>
{
    using type =
        phosphor::logging::xyz::openbmc_project::nvme::status::BackupDeviceFault;
};

} // namespace details
namespace xyz::openbmc_project::dump::create
{

struct Disabled
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::dump::create

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Dump::Create
{
using Disabled =
    phosphor::logging::xyz::openbmc_project::dump::create::Disabled;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::dump::create::Disabled>
{
    using type =
        phosphor::logging::xyz::openbmc_project::dump::create::Disabled;
};

} // namespace details
namespace xyz::openbmc_project::dump::create
{
namespace _QuotaExceeded
{
struct REASON
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON";
    using type = std::tuple<std::decay_t<decltype("REASON=%s")>,const char*>;
    explicit constexpr REASON(const char* a) : _entry(entry("REASON=%s", a)) {};
    type _entry;
};
} // namespace _QuotaExceeded

struct QuotaExceeded
{
    static constexpr auto L = level::ERR;
    using REASON = _QuotaExceeded::REASON;
    using metadata_types = std::tuple<REASON>;
};

} // namespace xyz::openbmc_project::dump::create

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Dump::Create
{
using QuotaExceeded =
    phosphor::logging::xyz::openbmc_project::dump::create::QuotaExceeded;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::dump::create::QuotaExceeded>
{
    using type =
        phosphor::logging::xyz::openbmc_project::dump::create::QuotaExceeded;
};

} // namespace details
namespace xyz::openbmc_project::user::common
{

struct UserNameExists
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::user::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::User::Common
{
using UserNameExists =
    phosphor::logging::xyz::openbmc_project::user::common::UserNameExists;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::user::common::UserNameExists>
{
    using type =
        phosphor::logging::xyz::openbmc_project::user::common::UserNameExists;
};

} // namespace details
namespace xyz::openbmc_project::user::common
{

struct UserNameDoesNotExist
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::user::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::User::Common
{
using UserNameDoesNotExist =
    phosphor::logging::xyz::openbmc_project::user::common::UserNameDoesNotExist;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::user::common::UserNameDoesNotExist>
{
    using type =
        phosphor::logging::xyz::openbmc_project::user::common::UserNameDoesNotExist;
};

} // namespace details
namespace xyz::openbmc_project::user::common
{
namespace _UserNameGroupFail
{
struct REASON
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON";
    using type = std::tuple<std::decay_t<decltype("REASON=%s")>,const char*>;
    explicit constexpr REASON(const char* a) : _entry(entry("REASON=%s", a)) {};
    type _entry;
};
} // namespace _UserNameGroupFail

struct UserNameGroupFail
{
    static constexpr auto L = level::ERR;
    using REASON = _UserNameGroupFail::REASON;
    using metadata_types = std::tuple<REASON>;
};

} // namespace xyz::openbmc_project::user::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::User::Common
{
using UserNameGroupFail =
    phosphor::logging::xyz::openbmc_project::user::common::UserNameGroupFail;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::user::common::UserNameGroupFail>
{
    using type =
        phosphor::logging::xyz::openbmc_project::user::common::UserNameGroupFail;
};

} // namespace details
namespace xyz::openbmc_project::user::common
{
namespace _UserNamePrivFail
{
struct REASON
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON";
    using type = std::tuple<std::decay_t<decltype("REASON=%s")>,const char*>;
    explicit constexpr REASON(const char* a) : _entry(entry("REASON=%s", a)) {};
    type _entry;
};
} // namespace _UserNamePrivFail

struct UserNamePrivFail
{
    static constexpr auto L = level::ERR;
    using REASON = _UserNamePrivFail::REASON;
    using metadata_types = std::tuple<REASON>;
};

} // namespace xyz::openbmc_project::user::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::User::Common
{
using UserNamePrivFail =
    phosphor::logging::xyz::openbmc_project::user::common::UserNamePrivFail;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::user::common::UserNamePrivFail>
{
    using type =
        phosphor::logging::xyz::openbmc_project::user::common::UserNamePrivFail;
};

} // namespace details
namespace xyz::openbmc_project::user::common
{
namespace _NoResource
{
struct REASON
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON";
    using type = std::tuple<std::decay_t<decltype("REASON=%s")>,const char*>;
    explicit constexpr REASON(const char* a) : _entry(entry("REASON=%s", a)) {};
    type _entry;
};
} // namespace _NoResource

struct NoResource
{
    static constexpr auto L = level::ERR;
    using REASON = _NoResource::REASON;
    using metadata_types = std::tuple<REASON>;
};

} // namespace xyz::openbmc_project::user::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::User::Common
{
using NoResource =
    phosphor::logging::xyz::openbmc_project::user::common::NoResource;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::user::common::NoResource>
{
    using type =
        phosphor::logging::xyz::openbmc_project::user::common::NoResource;
};

} // namespace details
namespace xyz::openbmc_project::user::common
{

struct PrivilegeMappingExists
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::user::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::User::Common
{
using PrivilegeMappingExists =
    phosphor::logging::xyz::openbmc_project::user::common::PrivilegeMappingExists;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::user::common::PrivilegeMappingExists>
{
    using type =
        phosphor::logging::xyz::openbmc_project::user::common::PrivilegeMappingExists;
};

} // namespace details
namespace xyz::openbmc_project::user::common
{

struct GroupNameExists
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::user::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::User::Common
{
using GroupNameExists =
    phosphor::logging::xyz::openbmc_project::user::common::GroupNameExists;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::user::common::GroupNameExists>
{
    using type =
        phosphor::logging::xyz::openbmc_project::user::common::GroupNameExists;
};

} // namespace details
namespace xyz::openbmc_project::user::common
{

struct GroupNameDoesNotExist
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::user::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::User::Common
{
using GroupNameDoesNotExist =
    phosphor::logging::xyz::openbmc_project::user::common::GroupNameDoesNotExist;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::user::common::GroupNameDoesNotExist>
{
    using type =
        phosphor::logging::xyz::openbmc_project::user::common::GroupNameDoesNotExist;
};

} // namespace details
namespace xyz::openbmc_project::software::version
{
namespace _Incompatible
{
struct MIN_VERSION
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "MIN_VERSION";
    using type = std::tuple<std::decay_t<decltype("MIN_VERSION=%s")>,const char*>;
    explicit constexpr MIN_VERSION(const char* a) : _entry(entry("MIN_VERSION=%s", a)) {};
    type _entry;
};
struct ACTUAL_VERSION
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ACTUAL_VERSION";
    using type = std::tuple<std::decay_t<decltype("ACTUAL_VERSION=%s")>,const char*>;
    explicit constexpr ACTUAL_VERSION(const char* a) : _entry(entry("ACTUAL_VERSION=%s", a)) {};
    type _entry;
};
struct VERSION_PURPOSE
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "VERSION_PURPOSE";
    using type = std::tuple<std::decay_t<decltype("VERSION_PURPOSE=%s")>,const char*>;
    explicit constexpr VERSION_PURPOSE(const char* a) : _entry(entry("VERSION_PURPOSE=%s", a)) {};
    type _entry;
};
} // namespace _Incompatible

struct Incompatible
{
    static constexpr auto L = level::ERR;
    using MIN_VERSION = _Incompatible::MIN_VERSION;
    using ACTUAL_VERSION = _Incompatible::ACTUAL_VERSION;
    using VERSION_PURPOSE = _Incompatible::VERSION_PURPOSE;
    using metadata_types = std::tuple<MIN_VERSION, ACTUAL_VERSION, VERSION_PURPOSE>;
};

} // namespace xyz::openbmc_project::software::version

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Software::Version
{
using Incompatible =
    phosphor::logging::xyz::openbmc_project::software::version::Incompatible;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::software::version::Incompatible>
{
    using type =
        phosphor::logging::xyz::openbmc_project::software::version::Incompatible;
};

} // namespace details
namespace xyz::openbmc_project::software::version
{
namespace _AlreadyExists
{
struct IMAGE_VERSION
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "IMAGE_VERSION";
    using type = std::tuple<std::decay_t<decltype("IMAGE_VERSION=%s")>,const char*>;
    explicit constexpr IMAGE_VERSION(const char* a) : _entry(entry("IMAGE_VERSION=%s", a)) {};
    type _entry;
};
} // namespace _AlreadyExists

struct AlreadyExists
{
    static constexpr auto L = level::ERR;
    using IMAGE_VERSION = _AlreadyExists::IMAGE_VERSION;
    using metadata_types = std::tuple<IMAGE_VERSION>;
};

} // namespace xyz::openbmc_project::software::version

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Software::Version
{
using AlreadyExists =
    phosphor::logging::xyz::openbmc_project::software::version::AlreadyExists;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::software::version::AlreadyExists>
{
    using type =
        phosphor::logging::xyz::openbmc_project::software::version::AlreadyExists;
};

} // namespace details
namespace xyz::openbmc_project::software::version
{

struct InvalidSignature
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::software::version

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Software::Version
{
using InvalidSignature =
    phosphor::logging::xyz::openbmc_project::software::version::InvalidSignature;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::software::version::InvalidSignature>
{
    using type =
        phosphor::logging::xyz::openbmc_project::software::version::InvalidSignature;
};

} // namespace details
namespace xyz::openbmc_project::state::systemd_target
{
namespace _Failure
{
struct SYSTEMD_RESULT
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "SYSTEMD_RESULT";
    using type = std::tuple<std::decay_t<decltype("SYSTEMD_RESULT=%s")>,const char*>;
    explicit constexpr SYSTEMD_RESULT(const char* a) : _entry(entry("SYSTEMD_RESULT=%s", a)) {};
    type _entry;
};
} // namespace _Failure

struct Failure
{
    static constexpr auto L = level::ERR;
    using SYSTEMD_RESULT = _Failure::SYSTEMD_RESULT;
    using metadata_types = std::tuple<SYSTEMD_RESULT>;
};

} // namespace xyz::openbmc_project::state::systemd_target

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::SystemdTarget
{
using Failure =
    phosphor::logging::xyz::openbmc_project::state::systemd_target::Failure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::systemd_target::Failure>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::systemd_target::Failure;
};

} // namespace details
namespace xyz::openbmc_project::state::host
{

struct SoftOffTimeout
{
    static constexpr auto L = level::ERR;
    using TIMEOUT_IN_MSEC =
        phosphor::logging::xyz::openbmc_project::common::Timeout::TIMEOUT_IN_MSEC;
    using metadata_types = std::tuple<TIMEOUT_IN_MSEC>;
};

} // namespace xyz::openbmc_project::state::host

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Host
{
using SoftOffTimeout =
    phosphor::logging::xyz::openbmc_project::state::host::SoftOffTimeout;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::host::SoftOffTimeout>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::host::SoftOffTimeout;
};

} // namespace details
namespace xyz::openbmc_project::state::host
{

struct HostStartFailure
{
    static constexpr auto L = level::ERR;
    using SYSTEMD_RESULT =
        phosphor::logging::xyz::openbmc_project::state::systemd_target::Failure::SYSTEMD_RESULT;
    using metadata_types = std::tuple<SYSTEMD_RESULT>;
};

} // namespace xyz::openbmc_project::state::host

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Host
{
using HostStartFailure =
    phosphor::logging::xyz::openbmc_project::state::host::HostStartFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::host::HostStartFailure>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::host::HostStartFailure;
};

} // namespace details
namespace xyz::openbmc_project::state::host
{

struct HostMinStartFailure
{
    static constexpr auto L = level::ERR;
    using SYSTEMD_RESULT =
        phosphor::logging::xyz::openbmc_project::state::systemd_target::Failure::SYSTEMD_RESULT;
    using metadata_types = std::tuple<SYSTEMD_RESULT>;
};

} // namespace xyz::openbmc_project::state::host

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Host
{
using HostMinStartFailure =
    phosphor::logging::xyz::openbmc_project::state::host::HostMinStartFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::host::HostMinStartFailure>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::host::HostMinStartFailure;
};

} // namespace details
namespace xyz::openbmc_project::state::host
{

struct HostShutdownFailure
{
    static constexpr auto L = level::ERR;
    using SYSTEMD_RESULT =
        phosphor::logging::xyz::openbmc_project::state::systemd_target::Failure::SYSTEMD_RESULT;
    using metadata_types = std::tuple<SYSTEMD_RESULT>;
};

} // namespace xyz::openbmc_project::state::host

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Host
{
using HostShutdownFailure =
    phosphor::logging::xyz::openbmc_project::state::host::HostShutdownFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::host::HostShutdownFailure>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::host::HostShutdownFailure;
};

} // namespace details
namespace xyz::openbmc_project::state::host
{

struct HostStopFailure
{
    static constexpr auto L = level::ERR;
    using SYSTEMD_RESULT =
        phosphor::logging::xyz::openbmc_project::state::systemd_target::Failure::SYSTEMD_RESULT;
    using metadata_types = std::tuple<SYSTEMD_RESULT>;
};

} // namespace xyz::openbmc_project::state::host

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Host
{
using HostStopFailure =
    phosphor::logging::xyz::openbmc_project::state::host::HostStopFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::host::HostStopFailure>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::host::HostStopFailure;
};

} // namespace details
namespace xyz::openbmc_project::state::host
{

struct HostRebootFailure
{
    static constexpr auto L = level::ERR;
    using SYSTEMD_RESULT =
        phosphor::logging::xyz::openbmc_project::state::systemd_target::Failure::SYSTEMD_RESULT;
    using metadata_types = std::tuple<SYSTEMD_RESULT>;
};

} // namespace xyz::openbmc_project::state::host

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Host
{
using HostRebootFailure =
    phosphor::logging::xyz::openbmc_project::state::host::HostRebootFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::host::HostRebootFailure>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::host::HostRebootFailure;
};

} // namespace details
namespace xyz::openbmc_project::state::host
{

struct BMCNotReady
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::state::host

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Host
{
using BMCNotReady =
    phosphor::logging::xyz::openbmc_project::state::host::BMCNotReady;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::host::BMCNotReady>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::host::BMCNotReady;
};

} // namespace details
namespace xyz::openbmc_project::state::chassis
{

struct PowerOnFailure
{
    static constexpr auto L = level::ERR;
    using SYSTEMD_RESULT =
        phosphor::logging::xyz::openbmc_project::state::systemd_target::Failure::SYSTEMD_RESULT;
    using metadata_types = std::tuple<SYSTEMD_RESULT>;
};

} // namespace xyz::openbmc_project::state::chassis

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Chassis
{
using PowerOnFailure =
    phosphor::logging::xyz::openbmc_project::state::chassis::PowerOnFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::chassis::PowerOnFailure>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::chassis::PowerOnFailure;
};

} // namespace details
namespace xyz::openbmc_project::state::chassis
{

struct PowerOffFailure
{
    static constexpr auto L = level::ERR;
    using SYSTEMD_RESULT =
        phosphor::logging::xyz::openbmc_project::state::systemd_target::Failure::SYSTEMD_RESULT;
    using metadata_types = std::tuple<SYSTEMD_RESULT>;
};

} // namespace xyz::openbmc_project::state::chassis

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Chassis
{
using PowerOffFailure =
    phosphor::logging::xyz::openbmc_project::state::chassis::PowerOffFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::chassis::PowerOffFailure>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::chassis::PowerOffFailure;
};

} // namespace details
namespace xyz::openbmc_project::state::chassis
{

struct PowerCycleFailure
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::state::chassis

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Chassis
{
using PowerCycleFailure =
    phosphor::logging::xyz::openbmc_project::state::chassis::PowerCycleFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::chassis::PowerCycleFailure>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::chassis::PowerCycleFailure;
};

} // namespace details
namespace xyz::openbmc_project::state::chassis
{

struct BMCNotReady
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::state::chassis

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Chassis
{
using BMCNotReady =
    phosphor::logging::xyz::openbmc_project::state::chassis::BMCNotReady;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::chassis::BMCNotReady>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::chassis::BMCNotReady;
};

} // namespace details
namespace xyz::openbmc_project::state::shutdown::power
{

struct Fault
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::state::shutdown::power

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Shutdown::Power
{
using Fault =
    phosphor::logging::xyz::openbmc_project::state::shutdown::power::Fault;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::shutdown::power::Fault>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::shutdown::power::Fault;
};

} // namespace details
namespace xyz::openbmc_project::state::shutdown::power
{

struct Blackout
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::state::shutdown::power

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Shutdown::Power
{
using Blackout =
    phosphor::logging::xyz::openbmc_project::state::shutdown::power::Blackout;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::shutdown::power::Blackout>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::shutdown::power::Blackout;
};

} // namespace details
namespace xyz::openbmc_project::state::shutdown::power
{

struct Regulator
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::state::shutdown::power

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Shutdown::Power
{
using Regulator =
    phosphor::logging::xyz::openbmc_project::state::shutdown::power::Regulator;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::shutdown::power::Regulator>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::shutdown::power::Regulator;
};

} // namespace details
namespace xyz::openbmc_project::state::shutdown::thermal_event
{

struct Processor
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::state::shutdown::thermal_event

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Shutdown::ThermalEvent
{
using Processor =
    phosphor::logging::xyz::openbmc_project::state::shutdown::thermal_event::Processor;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::shutdown::thermal_event::Processor>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::shutdown::thermal_event::Processor;
};

} // namespace details
namespace xyz::openbmc_project::state::shutdown::thermal_event
{

struct GPU
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::state::shutdown::thermal_event

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Shutdown::ThermalEvent
{
using GPU =
    phosphor::logging::xyz::openbmc_project::state::shutdown::thermal_event::GPU;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::shutdown::thermal_event::GPU>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::shutdown::thermal_event::GPU;
};

} // namespace details
namespace xyz::openbmc_project::state::shutdown::thermal_event
{

struct Ambient
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::state::shutdown::thermal_event

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Shutdown::ThermalEvent
{
using Ambient =
    phosphor::logging::xyz::openbmc_project::state::shutdown::thermal_event::Ambient;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::shutdown::thermal_event::Ambient>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::shutdown::thermal_event::Ambient;
};

} // namespace details
namespace xyz::openbmc_project::state::shutdown::inventory
{

struct Fan
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::state::shutdown::inventory

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::Shutdown::Inventory
{
using Fan =
    phosphor::logging::xyz::openbmc_project::state::shutdown::inventory::Fan;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::shutdown::inventory::Fan>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::shutdown::inventory::Fan;
};

} // namespace details
namespace xyz::openbmc_project::memory::memory_ecc
{

struct IsLoggingLimitReached
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::memory::memory_ecc

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Memory::MemoryECC
{
using isLoggingLimitReached =
    phosphor::logging::xyz::openbmc_project::memory::memory_ecc::IsLoggingLimitReached;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::memory::memory_ecc::IsLoggingLimitReached>
{
    using type =
        phosphor::logging::xyz::openbmc_project::memory::memory_ecc::IsLoggingLimitReached;
};

} // namespace details
namespace xyz::openbmc_project::memory::memory_ecc
{

struct CeCount
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::memory::memory_ecc

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Memory::MemoryECC
{
using ceCount =
    phosphor::logging::xyz::openbmc_project::memory::memory_ecc::CeCount;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::memory::memory_ecc::CeCount>
{
    using type =
        phosphor::logging::xyz::openbmc_project::memory::memory_ecc::CeCount;
};

} // namespace details
namespace xyz::openbmc_project::memory::memory_ecc
{

struct UeCount
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::memory::memory_ecc

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Memory::MemoryECC
{
using ueCount =
    phosphor::logging::xyz::openbmc_project::memory::memory_ecc::UeCount;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::memory::memory_ecc::UeCount>
{
    using type =
        phosphor::logging::xyz::openbmc_project::memory::memory_ecc::UeCount;
};

} // namespace details
namespace xyz::openbmc_project::chassis::common
{

struct UnsupportedCommand
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::chassis::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Chassis::Common
{
using UnsupportedCommand =
    phosphor::logging::xyz::openbmc_project::chassis::common::UnsupportedCommand;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::chassis::common::UnsupportedCommand>
{
    using type =
        phosphor::logging::xyz::openbmc_project::chassis::common::UnsupportedCommand;
};

} // namespace details
namespace xyz::openbmc_project::chassis::common
{

struct IOError
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::chassis::common

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Chassis::Common
{
using IOError =
    phosphor::logging::xyz::openbmc_project::chassis::common::IOError;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::chassis::common::IOError>
{
    using type =
        phosphor::logging::xyz::openbmc_project::chassis::common::IOError;
};

} // namespace details
namespace xyz::openbmc_project::smbios::mdr_v2
{

struct InvalidParameter
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::smbios::mdr_v2

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Smbios::MDR_V2
{
using InvalidParameter =
    phosphor::logging::xyz::openbmc_project::smbios::mdr_v2::InvalidParameter;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::smbios::mdr_v2::InvalidParameter>
{
    using type =
        phosphor::logging::xyz::openbmc_project::smbios::mdr_v2::InvalidParameter;
};

} // namespace details
namespace xyz::openbmc_project::smbios::mdr_v2
{

struct UpdateInProgress
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::smbios::mdr_v2

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Smbios::MDR_V2
{
using UpdateInProgress =
    phosphor::logging::xyz::openbmc_project::smbios::mdr_v2::UpdateInProgress;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::smbios::mdr_v2::UpdateInProgress>
{
    using type =
        phosphor::logging::xyz::openbmc_project::smbios::mdr_v2::UpdateInProgress;
};

} // namespace details
namespace xyz::openbmc_project::smbios::mdr_v2
{

struct InvalidId
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;
};

} // namespace xyz::openbmc_project::smbios::mdr_v2

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Smbios::MDR_V2
{
using InvalidId =
    phosphor::logging::xyz::openbmc_project::smbios::mdr_v2::InvalidId;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::smbios::mdr_v2::InvalidId>
{
    using type =
        phosphor::logging::xyz::openbmc_project::smbios::mdr_v2::InvalidId;
};

} // namespace details
namespace xyz::openbmc_project::logging::sel
{
namespace _Created
{
struct RECORD_TYPE
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "RECORD_TYPE";
    using type = std::tuple<std::decay_t<decltype("RECORD_TYPE=%u")>,uint8_t>;
    explicit constexpr RECORD_TYPE(uint8_t a) : _entry(entry("RECORD_TYPE=%u", a)) {};
    type _entry;
};
struct GENERATOR_ID
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "GENERATOR_ID";
    using type = std::tuple<std::decay_t<decltype("GENERATOR_ID=%u")>,uint16_t>;
    explicit constexpr GENERATOR_ID(uint16_t a) : _entry(entry("GENERATOR_ID=%u", a)) {};
    type _entry;
};
struct SENSOR_DATA
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "SENSOR_DATA";
    using type = std::tuple<std::decay_t<decltype("SENSOR_DATA=%s")>,const char*>;
    explicit constexpr SENSOR_DATA(const char* a) : _entry(entry("SENSOR_DATA=%s", a)) {};
    type _entry;
};
struct EVENT_DIR
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "EVENT_DIR";
    using type = std::tuple<std::decay_t<decltype("EVENT_DIR=%u")>,uint8_t>;
    explicit constexpr EVENT_DIR(uint8_t a) : _entry(entry("EVENT_DIR=%u", a)) {};
    type _entry;
};
struct SENSOR_PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "SENSOR_PATH";
    using type = std::tuple<std::decay_t<decltype("SENSOR_PATH=%s")>,const char*>;
    explicit constexpr SENSOR_PATH(const char* a) : _entry(entry("SENSOR_PATH=%s", a)) {};
    type _entry;
};
} // namespace _Created

struct Created
{
    static constexpr auto L = level::INFO;
    using RECORD_TYPE = _Created::RECORD_TYPE;
    using GENERATOR_ID = _Created::GENERATOR_ID;
    using SENSOR_DATA = _Created::SENSOR_DATA;
    using EVENT_DIR = _Created::EVENT_DIR;
    using SENSOR_PATH = _Created::SENSOR_PATH;
    using metadata_types = std::tuple<RECORD_TYPE, GENERATOR_ID, SENSOR_DATA, EVENT_DIR, SENSOR_PATH>;
};

} // namespace xyz::openbmc_project::logging::sel

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Logging::SEL
{
using Created =
    phosphor::logging::xyz::openbmc_project::logging::sel::Created;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::logging::sel::Created>
{
    using type =
        phosphor::logging::xyz::openbmc_project::logging::sel::Created;
};

} // namespace details
namespace xyz::openbmc_project::sensor::device
{

struct ReadFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;
};

} // namespace xyz::openbmc_project::sensor::device

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Sensor::Device
{
using ReadFailure =
    phosphor::logging::xyz::openbmc_project::sensor::device::ReadFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::sensor::device::ReadFailure>
{
    using type =
        phosphor::logging::xyz::openbmc_project::sensor::device::ReadFailure;
};

} // namespace details
namespace xyz::openbmc_project::sensor::threshold
{
namespace _CriticalHigh
{
struct SENSOR_DATA
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "SENSOR_DATA";
    using type = std::tuple<std::decay_t<decltype("SENSOR_DATA=%s")>,const char*>;
    explicit constexpr SENSOR_DATA(const char* a) : _entry(entry("SENSOR_DATA=%s", a)) {};
    type _entry;
};
} // namespace _CriticalHigh

struct CriticalHigh
{
    static constexpr auto L = level::ERR;
    using SENSOR_DATA = _CriticalHigh::SENSOR_DATA;
    using metadata_types = std::tuple<SENSOR_DATA>;
};

} // namespace xyz::openbmc_project::sensor::threshold

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Sensor::Threshold
{
using CriticalHigh =
    phosphor::logging::xyz::openbmc_project::sensor::threshold::CriticalHigh;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::sensor::threshold::CriticalHigh>
{
    using type =
        phosphor::logging::xyz::openbmc_project::sensor::threshold::CriticalHigh;
};

} // namespace details
namespace xyz::openbmc_project::sensor::threshold
{
namespace _CriticalLow
{
struct SENSOR_DATA
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "SENSOR_DATA";
    using type = std::tuple<std::decay_t<decltype("SENSOR_DATA=%s")>,const char*>;
    explicit constexpr SENSOR_DATA(const char* a) : _entry(entry("SENSOR_DATA=%s", a)) {};
    type _entry;
};
} // namespace _CriticalLow

struct CriticalLow
{
    static constexpr auto L = level::ERR;
    using SENSOR_DATA = _CriticalLow::SENSOR_DATA;
    using metadata_types = std::tuple<SENSOR_DATA>;
};

} // namespace xyz::openbmc_project::sensor::threshold

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Sensor::Threshold
{
using CriticalLow =
    phosphor::logging::xyz::openbmc_project::sensor::threshold::CriticalLow;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::sensor::threshold::CriticalLow>
{
    using type =
        phosphor::logging::xyz::openbmc_project::sensor::threshold::CriticalLow;
};

} // namespace details
namespace example::xyz::openbmc_project::example::device
{
namespace _Callout
{
struct CALLOUT_ERRNO_TEST
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_ERRNO_TEST";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_ERRNO_TEST=%d")>,int32_t>;
    explicit constexpr CALLOUT_ERRNO_TEST(int32_t a) : _entry(entry("CALLOUT_ERRNO_TEST=%d", a)) {};
    type _entry;
};
struct CALLOUT_DEVICE_PATH_TEST
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "CALLOUT_DEVICE_PATH_TEST";
    using type = std::tuple<std::decay_t<decltype("CALLOUT_DEVICE_PATH_TEST=%s")>,const char*>;
    explicit constexpr CALLOUT_DEVICE_PATH_TEST(const char* a) : _entry(entry("CALLOUT_DEVICE_PATH_TEST=%s", a)) {};
    type _entry;
};
} // namespace _Callout

struct Callout : public sdbusplus::exception_t
{
    static constexpr auto errName = "example.xyz.openbmc_project.Example.Device.Callout";
    static constexpr auto errDesc = "Generic device callout";
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO_TEST = _Callout::CALLOUT_ERRNO_TEST;
    using CALLOUT_DEVICE_PATH_TEST = _Callout::CALLOUT_DEVICE_PATH_TEST;
    using metadata_types = std::tuple<CALLOUT_ERRNO_TEST, CALLOUT_DEVICE_PATH_TEST>;

    const char* name() const noexcept override
    {
        return errName;
    }

    const char* description() const noexcept override
    {
        return errDesc;
    }

    const char* what() const noexcept override
    {
        return errName;
    }

    int get_errno() const noexcept override
    {
        return EIO;
    }
};

} // namespace example::xyz::openbmc_project::example::device

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace example::xyz::openbmc_project::Example::Device
{
using Callout =
    phosphor::logging::example::xyz::openbmc_project::example::device::Callout;
}
#endif

namespace example::xyz::openbmc_project::example::elog
{
namespace _TestErrorTwo
{
struct DEV_ADDR
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "DEV_ADDR";
    using type = std::tuple<std::decay_t<decltype("DEV_ADDR=0x%.8X")>,uint32_t>;
    explicit constexpr DEV_ADDR(uint32_t a) : _entry(entry("DEV_ADDR=0x%.8X", a)) {};
    type _entry;
};
struct DEV_ID
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "DEV_ID";
    using type = std::tuple<std::decay_t<decltype("DEV_ID=%u")>,uint32_t>;
    explicit constexpr DEV_ID(uint32_t a) : _entry(entry("DEV_ID=%u", a)) {};
    type _entry;
};
struct DEV_NAME
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "DEV_NAME";
    using type = std::tuple<std::decay_t<decltype("DEV_NAME=%s")>,const char*>;
    explicit constexpr DEV_NAME(const char* a) : _entry(entry("DEV_NAME=%s", a)) {};
    type _entry;
};
} // namespace _TestErrorTwo

struct TestErrorTwo : public sdbusplus::exception_t
{
    static constexpr auto errName = "example.xyz.openbmc_project.Example.Elog.TestErrorTwo";
    static constexpr auto errDesc = "This is test error two";
    static constexpr auto L = level::ERR;
    using DEV_ADDR = _TestErrorTwo::DEV_ADDR;
    using DEV_ID = _TestErrorTwo::DEV_ID;
    using DEV_NAME = _TestErrorTwo::DEV_NAME;
    using metadata_types = std::tuple<DEV_ADDR, DEV_ID, DEV_NAME>;

    const char* name() const noexcept override
    {
        return errName;
    }

    const char* description() const noexcept override
    {
        return errDesc;
    }

    const char* what() const noexcept override
    {
        return errName;
    }

    int get_errno() const noexcept override
    {
        return EIO;
    }
};

} // namespace example::xyz::openbmc_project::example::elog

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace example::xyz::openbmc_project::Example::Elog
{
using TestErrorTwo =
    phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorTwo;
}
#endif

namespace example::xyz::openbmc_project::example::elog
{
namespace _AutoTestSimple
{
struct STRING
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "STRING";
    using type = std::tuple<std::decay_t<decltype("STRING=%s")>,const char*>;
    explicit constexpr STRING(const char* a) : _entry(entry("STRING=%s", a)) {};
    type _entry;
};
} // namespace _AutoTestSimple

struct AutoTestSimple : public sdbusplus::exception_t
{
    static constexpr auto errName = "example.xyz.openbmc_project.Example.Elog.AutoTestSimple";
    static constexpr auto errDesc = "This is a simple test error.";
    static constexpr auto L = level::ERR;
    using STRING = _AutoTestSimple::STRING;
    using metadata_types = std::tuple<STRING>;

    const char* name() const noexcept override
    {
        return errName;
    }

    const char* description() const noexcept override
    {
        return errDesc;
    }

    const char* what() const noexcept override
    {
        return errName;
    }

    int get_errno() const noexcept override
    {
        return EIO;
    }
};

} // namespace example::xyz::openbmc_project::example::elog

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace example::xyz::openbmc_project::Example::Elog
{
using AutoTestSimple =
    phosphor::logging::example::xyz::openbmc_project::example::elog::AutoTestSimple;
}
#endif

namespace example::xyz::openbmc_project::example::elog
{
namespace _TestCallout
{
struct DEV_ADDR
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "DEV_ADDR";
    using type = std::tuple<std::decay_t<decltype("DEV_ADDR=0x%.8X")>,uint32_t>;
    explicit constexpr DEV_ADDR(uint32_t a) : _entry(entry("DEV_ADDR=0x%.8X", a)) {};
    type _entry;
};
} // namespace _TestCallout

struct TestCallout : public sdbusplus::exception_t
{
    static constexpr auto errName = "example.xyz.openbmc_project.Example.Elog.TestCallout";
    static constexpr auto errDesc = "This is test error TestCallout";
    static constexpr auto L = level::ERR;
    using DEV_ADDR = _TestCallout::DEV_ADDR;
    using CALLOUT_ERRNO_TEST =
        phosphor::logging::example::xyz::openbmc_project::example::device::Callout::CALLOUT_ERRNO_TEST;
    using CALLOUT_DEVICE_PATH_TEST =
        phosphor::logging::example::xyz::openbmc_project::example::device::Callout::CALLOUT_DEVICE_PATH_TEST;
    using metadata_types = std::tuple<DEV_ADDR, CALLOUT_ERRNO_TEST, CALLOUT_DEVICE_PATH_TEST>;

    const char* name() const noexcept override
    {
        return errName;
    }

    const char* description() const noexcept override
    {
        return errDesc;
    }

    const char* what() const noexcept override
    {
        return errName;
    }

    int get_errno() const noexcept override
    {
        return EIO;
    }
};

} // namespace example::xyz::openbmc_project::example::elog

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace example::xyz::openbmc_project::Example::Elog
{
using TestCallout =
    phosphor::logging::example::xyz::openbmc_project::example::elog::TestCallout;
}
#endif

namespace org::open_power::host
{
namespace _Event
{
struct ESEL
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ESEL";
    using type = std::tuple<std::decay_t<decltype("ESEL=%s")>,const char*>;
    explicit constexpr ESEL(const char* a) : _entry(entry("ESEL=%s", a)) {};
    type _entry;
};
} // namespace _Event

struct Event
{
    static constexpr auto L = level::ERR;
    using ESEL = _Event::ESEL;
    using CALLOUT_INVENTORY_PATH =
        phosphor::logging::xyz::openbmc_project::common::callout::Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<ESEL, CALLOUT_INVENTORY_PATH>;
};

} // namespace org::open_power::host

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace org::open_power::Host
{
using Event =
    phosphor::logging::org::open_power::host::Event;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::org::open_power::host::Event>
{
    using type =
        phosphor::logging::org::open_power::host::Event;
};

} // namespace details
namespace org::open_power::host
{
namespace _MaintenanceProcedure
{
struct ESEL
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ESEL";
    using type = std::tuple<std::decay_t<decltype("ESEL=%s")>,const char*>;
    explicit constexpr ESEL(const char* a) : _entry(entry("ESEL=%s", a)) {};
    type _entry;
};
} // namespace _MaintenanceProcedure

struct MaintenanceProcedure
{
    static constexpr auto L = level::ERR;
    using ESEL = _MaintenanceProcedure::ESEL;
    using PROCEDURE =
        phosphor::logging::org::open_power::common::callout::Procedure::PROCEDURE;
    using metadata_types = std::tuple<ESEL, PROCEDURE>;
};

} // namespace org::open_power::host

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace org::open_power::Host
{
using MaintenanceProcedure =
    phosphor::logging::org::open_power::host::MaintenanceProcedure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::org::open_power::host::MaintenanceProcedure>
{
    using type =
        phosphor::logging::org::open_power::host::MaintenanceProcedure;
};

} // namespace details
namespace org::open_power::proc::fsi
{

struct MasterDetectionFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;
};

} // namespace org::open_power::proc::fsi

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace org::open_power::Proc::FSI
{
using MasterDetectionFailure =
    phosphor::logging::org::open_power::proc::fsi::MasterDetectionFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::org::open_power::proc::fsi::MasterDetectionFailure>
{
    using type =
        phosphor::logging::org::open_power::proc::fsi::MasterDetectionFailure;
};

} // namespace details
namespace org::open_power::occ::device
{

struct OpenFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;
};

} // namespace org::open_power::occ::device

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace org::open_power::OCC::Device
{
using OpenFailure =
    phosphor::logging::org::open_power::occ::device::OpenFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::org::open_power::occ::device::OpenFailure>
{
    using type =
        phosphor::logging::org::open_power::occ::device::OpenFailure;
};

} // namespace details
namespace org::open_power::occ::device
{

struct ReadFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;
};

} // namespace org::open_power::occ::device

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace org::open_power::OCC::Device
{
using ReadFailure =
    phosphor::logging::org::open_power::occ::device::ReadFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::org::open_power::occ::device::ReadFailure>
{
    using type =
        phosphor::logging::org::open_power::occ::device::ReadFailure;
};

} // namespace details
namespace org::open_power::occ::device
{

struct WriteFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;
};

} // namespace org::open_power::occ::device

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace org::open_power::OCC::Device
{
using WriteFailure =
    phosphor::logging::org::open_power::occ::device::WriteFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::org::open_power::occ::device::WriteFailure>
{
    using type =
        phosphor::logging::org::open_power::occ::device::WriteFailure;
};

} // namespace details
namespace org::open_power::occ::device
{

struct ConfigFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;
};

} // namespace org::open_power::occ::device

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace org::open_power::OCC::Device
{
using ConfigFailure =
    phosphor::logging::org::open_power::occ::device::ConfigFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::org::open_power::occ::device::ConfigFailure>
{
    using type =
        phosphor::logging::org::open_power::occ::device::ConfigFailure;
};

} // namespace details
namespace org::open_power::host::access
{
namespace _WriteCFAM
{
struct ADDRESS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ADDRESS";
    using type = std::tuple<std::decay_t<decltype("ADDRESS=0x%X")>,uint32_t>;
    explicit constexpr ADDRESS(uint32_t a) : _entry(entry("ADDRESS=0x%X", a)) {};
    type _entry;
};
} // namespace _WriteCFAM

struct WriteCFAM
{
    static constexpr auto L = level::ERR;
    using ADDRESS = _WriteCFAM::ADDRESS;
    using CALLOUT_ERRNO =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<ADDRESS, CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;
};

} // namespace org::open_power::host::access

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace org::open_power::Host::Access
{
using WriteCFAM =
    phosphor::logging::org::open_power::host::access::WriteCFAM;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::org::open_power::host::access::WriteCFAM>
{
    using type =
        phosphor::logging::org::open_power::host::access::WriteCFAM;
};

} // namespace details
namespace org::open_power::host::access
{
namespace _ReadCFAM
{
struct ADDRESS
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ADDRESS";
    using type = std::tuple<std::decay_t<decltype("ADDRESS=0x%X")>,uint32_t>;
    explicit constexpr ADDRESS(uint32_t a) : _entry(entry("ADDRESS=0x%X", a)) {};
    type _entry;
};
} // namespace _ReadCFAM

struct ReadCFAM
{
    static constexpr auto L = level::ERR;
    using ADDRESS = _ReadCFAM::ADDRESS;
    using CALLOUT_ERRNO =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<ADDRESS, CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;
};

} // namespace org::open_power::host::access

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace org::open_power::Host::Access
{
using ReadCFAM =
    phosphor::logging::org::open_power::host::access::ReadCFAM;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::org::open_power::host::access::ReadCFAM>
{
    using type =
        phosphor::logging::org::open_power::host::access::ReadCFAM;
};

} // namespace details
namespace xyz::openbmc_project::time
{
namespace _NotAllowed
{
struct OWNER
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "OWNER";
    using type = std::tuple<std::decay_t<decltype("OWNER=%s")>,const char*>;
    explicit constexpr OWNER(const char* a) : _entry(entry("OWNER=%s", a)) {};
    type _entry;
};
struct SYNC_METHOD
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "SYNC_METHOD";
    using type = std::tuple<std::decay_t<decltype("SYNC_METHOD=%s")>,const char*>;
    explicit constexpr SYNC_METHOD(const char* a) : _entry(entry("SYNC_METHOD=%s", a)) {};
    type _entry;
};
} // namespace _NotAllowed

struct NotAllowed
{
    static constexpr auto L = level::ERR;
    using OWNER = _NotAllowed::OWNER;
    using SYNC_METHOD = _NotAllowed::SYNC_METHOD;
    using REASON =
        phosphor::logging::xyz::openbmc_project::common::NotAllowed::REASON;
    using metadata_types = std::tuple<OWNER, SYNC_METHOD, REASON>;
};

} // namespace xyz::openbmc_project::time

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Time
{
using NotAllowed =
    phosphor::logging::xyz::openbmc_project::time::NotAllowed;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::time::NotAllowed>
{
    using type =
        phosphor::logging::xyz::openbmc_project::time::NotAllowed;
};

} // namespace details
namespace xyz::openbmc_project::time
{
namespace _Failed
{
struct REASON
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "REASON";
    using type = std::tuple<std::decay_t<decltype("REASON=%s")>,const char*>;
    explicit constexpr REASON(const char* a) : _entry(entry("REASON=%s", a)) {};
    type _entry;
};
} // namespace _Failed

struct Failed
{
    static constexpr auto L = level::ERR;
    using REASON = _Failed::REASON;
    using metadata_types = std::tuple<REASON>;
};

} // namespace xyz::openbmc_project::time

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Time
{
using Failed =
    phosphor::logging::xyz::openbmc_project::time::Failed;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::time::Failed>
{
    using type =
        phosphor::logging::xyz::openbmc_project::time::Failed;
};

} // namespace details
namespace xyz::openbmc_project::inventory
{

struct NotPresent
{
    static constexpr auto L = level::ERR;
    using CALLOUT_INVENTORY_PATH =
        phosphor::logging::xyz::openbmc_project::common::callout::Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<CALLOUT_INVENTORY_PATH>;
};

} // namespace xyz::openbmc_project::inventory

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Inventory
{
using NotPresent =
    phosphor::logging::xyz::openbmc_project::inventory::NotPresent;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::inventory::NotPresent>
{
    using type =
        phosphor::logging::xyz::openbmc_project::inventory::NotPresent;
};

} // namespace details
namespace xyz::openbmc_project::inventory
{

struct Nonfunctional
{
    static constexpr auto L = level::ERR;
    using CALLOUT_INVENTORY_PATH =
        phosphor::logging::xyz::openbmc_project::common::callout::Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<CALLOUT_INVENTORY_PATH>;
};

} // namespace xyz::openbmc_project::inventory

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Inventory
{
using Nonfunctional =
    phosphor::logging::xyz::openbmc_project::inventory::Nonfunctional;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::inventory::Nonfunctional>
{
    using type =
        phosphor::logging::xyz::openbmc_project::inventory::Nonfunctional;
};

} // namespace details
namespace xyz::openbmc_project::control::device
{

struct WriteFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH =
        phosphor::logging::xyz::openbmc_project::common::callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;
};

} // namespace xyz::openbmc_project::control::device

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::Control::Device
{
using WriteFailure =
    phosphor::logging::xyz::openbmc_project::control::device::WriteFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::control::device::WriteFailure>
{
    using type =
        phosphor::logging::xyz::openbmc_project::control::device::WriteFailure;
};

} // namespace details
namespace xyz::openbmc_project::state::bmc
{

struct MultiUserTargetFailure
{
    static constexpr auto L = level::ERR;
    using SYSTEMD_RESULT =
        phosphor::logging::xyz::openbmc_project::state::systemd_target::Failure::SYSTEMD_RESULT;
    using metadata_types = std::tuple<SYSTEMD_RESULT>;
};

} // namespace xyz::openbmc_project::state::bmc

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace xyz::openbmc_project::State::BMC
{
using MultiUserTargetFailure =
    phosphor::logging::xyz::openbmc_project::state::bmc::MultiUserTargetFailure;
}
#endif

namespace details
{

template <>
struct map_exception_type<sdbusplus::error::xyz::openbmc_project::state::bmc::MultiUserTargetFailure>
{
    using type =
        phosphor::logging::xyz::openbmc_project::state::bmc::MultiUserTargetFailure;
};

} // namespace details
namespace example::xyz::openbmc_project::example::elog
{
namespace _TestErrorOne
{
struct ERRNUM
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "ERRNUM";
    using type = std::tuple<std::decay_t<decltype("ERRNUM=0x%.4X")>,uint16_t>;
    explicit constexpr ERRNUM(uint16_t a) : _entry(entry("ERRNUM=0x%.4X", a)) {};
    type _entry;
};
struct FILE_PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "FILE_PATH";
    using type = std::tuple<std::decay_t<decltype("FILE_PATH=%s")>,const char*>;
    explicit constexpr FILE_PATH(const char* a) : _entry(entry("FILE_PATH=%s", a)) {};
    type _entry;
};
struct FILE_NAME
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "FILE_NAME";
    using type = std::tuple<std::decay_t<decltype("FILE_NAME=%s")>,const char*>;
    explicit constexpr FILE_NAME(const char* a) : _entry(entry("FILE_NAME=%s", a)) {};
    type _entry;
};
} // namespace _TestErrorOne

struct TestErrorOne : public sdbusplus::exception_t
{
    static constexpr auto errName = "example.xyz.openbmc_project.Example.Elog.TestErrorOne";
    static constexpr auto errDesc = "this is test error one";
    static constexpr auto L = level::INFO;
    using ERRNUM = _TestErrorOne::ERRNUM;
    using FILE_PATH = _TestErrorOne::FILE_PATH;
    using FILE_NAME = _TestErrorOne::FILE_NAME;
    using DEV_ADDR =
        phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorTwo::DEV_ADDR;
    using DEV_ID =
        phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorTwo::DEV_ID;
    using DEV_NAME =
        phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorTwo::DEV_NAME;
    using metadata_types = std::tuple<ERRNUM, FILE_PATH, FILE_NAME, DEV_ADDR, DEV_ID, DEV_NAME>;

    const char* name() const noexcept override
    {
        return errName;
    }

    const char* description() const noexcept override
    {
        return errDesc;
    }

    const char* what() const noexcept override
    {
        return errName;
    }

    int get_errno() const noexcept override
    {
        return EIO;
    }
};

} // namespace example::xyz::openbmc_project::example::elog

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace example::xyz::openbmc_project::Example::Elog
{
using TestErrorOne =
    phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorOne;
}
#endif

namespace example::xyz::openbmc_project::example::foo
{
namespace _Foo
{
struct FOO_DATA
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "FOO_DATA";
    using type = std::tuple<std::decay_t<decltype("FOO_DATA=%s")>,const char*>;
    explicit constexpr FOO_DATA(const char* a) : _entry(entry("FOO_DATA=%s", a)) {};
    type _entry;
};
} // namespace _Foo

struct Foo : public sdbusplus::exception_t
{
    static constexpr auto errName = "example.xyz.openbmc_project.Example.Foo.Foo";
    static constexpr auto errDesc = "this is test error Foo";
    static constexpr auto L = level::INFO;
    using FOO_DATA = _Foo::FOO_DATA;
    using ERRNUM =
        phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorOne::ERRNUM;
    using FILE_PATH =
        phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorOne::FILE_PATH;
    using FILE_NAME =
        phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorOne::FILE_NAME;
    using DEV_ADDR =
        phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorTwo::DEV_ADDR;
    using DEV_ID =
        phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorTwo::DEV_ID;
    using DEV_NAME =
        phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorTwo::DEV_NAME;
    using metadata_types = std::tuple<FOO_DATA, ERRNUM, FILE_PATH, FILE_NAME, DEV_ADDR, DEV_ID, DEV_NAME>;

    const char* name() const noexcept override
    {
        return errName;
    }

    const char* description() const noexcept override
    {
        return errDesc;
    }

    const char* what() const noexcept override
    {
        return errName;
    }

    int get_errno() const noexcept override
    {
        return EIO;
    }
};

} // namespace example::xyz::openbmc_project::example::foo

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace example::xyz::openbmc_project::Example::Foo
{
using Foo =
    phosphor::logging::example::xyz::openbmc_project::example::foo::Foo;
}
#endif

namespace example::xyz::openbmc_project::example::bar
{
namespace _Bar
{
struct BAR_DATA
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "BAR_DATA";
    using type = std::tuple<std::decay_t<decltype("BAR_DATA=%s")>,const char*>;
    explicit constexpr BAR_DATA(const char* a) : _entry(entry("BAR_DATA=%s", a)) {};
    type _entry;
};
} // namespace _Bar

struct Bar : public sdbusplus::exception_t
{
    static constexpr auto errName = "example.xyz.openbmc_project.Example.Bar.Bar";
    static constexpr auto errDesc = "this is test error Bar";
    static constexpr auto L = level::INFO;
    using BAR_DATA = _Bar::BAR_DATA;
    using FOO_DATA =
        phosphor::logging::example::xyz::openbmc_project::example::foo::Foo::FOO_DATA;
    using ERRNUM =
        phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorOne::ERRNUM;
    using FILE_PATH =
        phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorOne::FILE_PATH;
    using FILE_NAME =
        phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorOne::FILE_NAME;
    using DEV_ADDR =
        phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorTwo::DEV_ADDR;
    using DEV_ID =
        phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorTwo::DEV_ID;
    using DEV_NAME =
        phosphor::logging::example::xyz::openbmc_project::example::elog::TestErrorTwo::DEV_NAME;
    using metadata_types = std::tuple<BAR_DATA, FOO_DATA, ERRNUM, FILE_PATH, FILE_NAME, DEV_ADDR, DEV_ID, DEV_NAME>;

    const char* name() const noexcept override
    {
        return errName;
    }

    const char* description() const noexcept override
    {
        return errDesc;
    }

    const char* what() const noexcept override
    {
        return errName;
    }

    int get_errno() const noexcept override
    {
        return EIO;
    }
};

} // namespace example::xyz::openbmc_project::example::bar

#ifndef SDBUSPP_REMOVE_DEPRECATED_NAMESPACE
namespace example::xyz::openbmc_project::Example::Bar
{
using Bar =
    phosphor::logging::example::xyz::openbmc_project::example::bar::Bar;
}
#endif

} // namespace phosphor::logging
